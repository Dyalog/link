{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Link allows you to use Unicode text files to store APL source code, rather than \"traditional\" binary workspaces. The benefits of using Link and text files include: It is easy to use source code management (SCM) tools like Git or Subversion to manage your code. Although an SCM is not a requirement for Link, Dyalog highly recommends using Git or similar systems to manage source code that Link will load into your APL session. Changes to your code are immediately written to file: there is no need to remember to save your work. The assumption is that you will make the record permanent with a commit to your source code management system, when the time is right. Unlike binary workspaces, text source can usually be shared between different versions of APL - or even with human readers or writers who don't have APL installed at all. Link is NOT... A source code management system : Link itself has no source code management features. As mentioned above, you will need to use a separate tool like Git to manage the source files that Link will allow you to use and modify from Dyalog APL. A database management system: although Link is able to store APL arrays using a pre-release of the literal array notation , this is only intended to be used for constants which you consider to be part of the source code of your applications. Although all functions and operators that you define using the editor will be written to source files by default, source files are only created for arrays by explicit calls to Link.Add or by specifying optional parameters to Link.Export . Application data should be stored in a database management system or files managed by the application. Link fundamentals Link establishes links between one or more namespaces in the active APL workspace and corresponding directories containing APL source code in Unicode test files. For example, the following user command invocation will link a namespace called myapp to the folder /home/sally/myapp : ]LINK.Create myapp /home/sally/myapp A set of API functions is available in the session namespace \u2395SE , for performing Link operations under programme control. Using the API, the above would be written: \u2395SE.Link.Create 'myapp' '/home/sally/myapp' If myapp contains sub-directories, a namespace hierarchy corresponding to the directory structure will be created within the myapp namespace. By default, the link is bi-directional, which means that Link will: Keep source files up-to-date: Any changes made to code in the active workspace using the tracer and editor are immediately replicated in the corresponding text files. Keep the workspace up-to-date: If .NET is available, then any changes made to the external files using a text editor, or resulting from an SCM action such as rolling back or switching to a different branch, will immediately be reflected in the active workspace. Note For Dyalog to automatically update workspace contents due to file changes requires .NET. The .NET Framework is included with Microsoft windows. For other platforms, .NET can be downloaded from dotnet.microsoft.com/download . To find out which versions are supported, see section 2.1 of the .NET Interface Guide and under the heading \"Prerequisites\" in chapter 1 of the Dyalog for Microsoft Windows .NET Framework Interface Guide . You can invoke Link.Create several times to create multiple links, and you can also use Link.Import or Link.Export to import source code into the workspace or export code to external files without creating links that will respond to subsequent changes. Functions vs. User Commands With a few exceptions, each Link API function has a corresponding User Command, designed to make the functionality slightly easier to use interactively in the session. User commands The user commands have the general syntax ]LINK.CmdName arg1 [arg2] [-name[=value] ...] where arg2 's presence depends on the specific command, -name is a flag enabling the specific option and -name=value sets that option to a specific value. Some options (like codeExtensions and typeExtensions ) require an array of values: in these cases the user commands typically take the name of a variable containing that array. For a list of installed user commands, type: ]LINK -? API functions The API is designed for use under program control, and options are provided in an optional namespace passed as the left argument. The general syntax of the utility functions is options FnName arguments where options is a namespace with variables, named according to the option they set, containing their corresponding values. The -name=value option can be set by options.name\u2190value , and switches with values (e.g. -name ) can be set by options.name\u21901 . Unset options will assume their default value. Options can also be provided as a character vector with the literal array representation of the option workspace, for example: '(name: 1)' FnName arguments The details of the arguments and options can be found in the API Reference . Further reading To get started using Link, please read: Basic Usage to see how to set up your first links, and learn about exporting existing application code to source files. Setting Up Your Environment for a discussion of how to set up Link-based development and runtime environments. Technical Details and Limitations if you want to know about the full range of APL objects that are supported, and some of the edge cases that are not yet supported by Link. If you have an existing APL application that you want to move to Link, you might want to read one of the following texts first: Converting Your Workspace to Text Source: if you already have an existing body of APL code in binary workspaces. Migrating to Link 3.0 from SALT: if you are already managing text source using Link's predecessor SALT. Frequently Asked Questions What happens if I save a workspace after creating Links? Are workspaces dead now? How is Link implemented?","title":"Introduction"},{"location":"#introduction","text":"Link allows you to use Unicode text files to store APL source code, rather than \"traditional\" binary workspaces. The benefits of using Link and text files include: It is easy to use source code management (SCM) tools like Git or Subversion to manage your code. Although an SCM is not a requirement for Link, Dyalog highly recommends using Git or similar systems to manage source code that Link will load into your APL session. Changes to your code are immediately written to file: there is no need to remember to save your work. The assumption is that you will make the record permanent with a commit to your source code management system, when the time is right. Unlike binary workspaces, text source can usually be shared between different versions of APL - or even with human readers or writers who don't have APL installed at all.","title":"Introduction"},{"location":"#link-is-not","text":"A source code management system : Link itself has no source code management features. As mentioned above, you will need to use a separate tool like Git to manage the source files that Link will allow you to use and modify from Dyalog APL. A database management system: although Link is able to store APL arrays using a pre-release of the literal array notation , this is only intended to be used for constants which you consider to be part of the source code of your applications. Although all functions and operators that you define using the editor will be written to source files by default, source files are only created for arrays by explicit calls to Link.Add or by specifying optional parameters to Link.Export . Application data should be stored in a database management system or files managed by the application.","title":"Link is NOT..."},{"location":"#link-fundamentals","text":"Link establishes links between one or more namespaces in the active APL workspace and corresponding directories containing APL source code in Unicode test files. For example, the following user command invocation will link a namespace called myapp to the folder /home/sally/myapp : ]LINK.Create myapp /home/sally/myapp A set of API functions is available in the session namespace \u2395SE , for performing Link operations under programme control. Using the API, the above would be written: \u2395SE.Link.Create 'myapp' '/home/sally/myapp' If myapp contains sub-directories, a namespace hierarchy corresponding to the directory structure will be created within the myapp namespace. By default, the link is bi-directional, which means that Link will: Keep source files up-to-date: Any changes made to code in the active workspace using the tracer and editor are immediately replicated in the corresponding text files. Keep the workspace up-to-date: If .NET is available, then any changes made to the external files using a text editor, or resulting from an SCM action such as rolling back or switching to a different branch, will immediately be reflected in the active workspace. Note For Dyalog to automatically update workspace contents due to file changes requires .NET. The .NET Framework is included with Microsoft windows. For other platforms, .NET can be downloaded from dotnet.microsoft.com/download . To find out which versions are supported, see section 2.1 of the .NET Interface Guide and under the heading \"Prerequisites\" in chapter 1 of the Dyalog for Microsoft Windows .NET Framework Interface Guide . You can invoke Link.Create several times to create multiple links, and you can also use Link.Import or Link.Export to import source code into the workspace or export code to external files without creating links that will respond to subsequent changes.","title":"Link fundamentals"},{"location":"#functions-vs-user-commands","text":"With a few exceptions, each Link API function has a corresponding User Command, designed to make the functionality slightly easier to use interactively in the session.","title":"Functions vs. User Commands"},{"location":"#user-commands","text":"The user commands have the general syntax ]LINK.CmdName arg1 [arg2] [-name[=value] ...] where arg2 's presence depends on the specific command, -name is a flag enabling the specific option and -name=value sets that option to a specific value. Some options (like codeExtensions and typeExtensions ) require an array of values: in these cases the user commands typically take the name of a variable containing that array. For a list of installed user commands, type: ]LINK -?","title":"User commands"},{"location":"#api-functions","text":"The API is designed for use under program control, and options are provided in an optional namespace passed as the left argument. The general syntax of the utility functions is options FnName arguments where options is a namespace with variables, named according to the option they set, containing their corresponding values. The -name=value option can be set by options.name\u2190value , and switches with values (e.g. -name ) can be set by options.name\u21901 . Unset options will assume their default value. Options can also be provided as a character vector with the literal array representation of the option workspace, for example: '(name: 1)' FnName arguments The details of the arguments and options can be found in the API Reference .","title":"API functions"},{"location":"#further-reading","text":"To get started using Link, please read: Basic Usage to see how to set up your first links, and learn about exporting existing application code to source files. Setting Up Your Environment for a discussion of how to set up Link-based development and runtime environments. Technical Details and Limitations if you want to know about the full range of APL objects that are supported, and some of the edge cases that are not yet supported by Link. If you have an existing APL application that you want to move to Link, you might want to read one of the following texts first: Converting Your Workspace to Text Source: if you already have an existing body of APL code in binary workspaces. Migrating to Link 3.0 from SALT: if you are already managing text source using Link's predecessor SALT.","title":"Further reading"},{"location":"#frequently-asked-questions","text":"What happens if I save a workspace after creating Links? Are workspaces dead now? How is Link implemented?","title":"Frequently Asked Questions"},{"location":"RPNotes/","text":"Rich's Notes Things which I haven't just directly changed since I'm not exactly sure how yet Sometimes components are referred to by UCMD syntax, sometimes by OOP syntax? Should get consistent... Probably \"API syntax\" followed by \"Also, here is UCMD version\"... the fact that help can be got with ]Link.FnName -? should probably be mentioned somewhere Technical APL jargon which needs clarifying in a separate document Active workspace The active workspace is the collection of names in an active Dyalog session. It consists of all of the names found using #.\u2395NL\u23739 , and possibly also #.\u2395SE . Simplified There are 3 ways to bring code in to or push code out from the active workspace. 1. Use Link.Create to create a bi-directional link. Changes made in the Dyalog editor are reflected in the text source on the file system, and changes made to the text source on the file system are reflected in the active workspace (viewable using the Dyalog editor). 1. Use Link.Import to import code from text source in a folder on the file system into a namespace in the active workspace. 1. Use Link.Export to export code from a namespace in the active workspace to a folder of text source files on the file system. It seems obvious, but somewhere it might be worth noting that - until/unless this is added as a specific feature - individual items can be written to file (\"exported\") by copying them into a new namespace and using Link.Export on that namespace. SCM for APLers This should be its own document, or possibliy repository Introduction Source code stored in external files is preserved exactly as typed, rather than being reconstructed from the tokenised form. This part is a little obtuse unless you already know about how Dyalog handles source code. It should probably be moved from this section and explained a little further, possibly in the History of Text Source section SCM for APLers should be its own document living somewhere in the Documentation/Learning materials/Information Ecosystem You can invoke ]LINK.Createseveral times to create multiple links, and you can also use ]LINK.Importor ]LINK.Export to import source code into the workspace or export code to external files without creating links that will respond to subsequent changes. This part should be more prominent somehow How do I import code and my changes not be saved? How can I make changes to my code without them being saved? Tech details Scripted namespaces: It is likely that this restriction will be lifted in a future version of Link. Once again mentioning the loss of text source fidelity. Should be explained somewhere else or linked to a more comprehensive explanation and some examples Maybe remove - because the APL interpreter does not have a source form for such items. With the exception of the scenarios \u2190 this paragraph needs small rework How does Link work? This section is really part of Technical Details and Limitations, but might... - version 3.0 only uses this for links with an endpoint in \u2395SE . \u2190 is this a change history issue? - It is expected that the APL language engine will support \u2190 Future stuff - will be able to run in the background and \u2190 what does \"in the background\" mean specifically? The fact that Link only acts automatically in response to changes made in editors should be made more prominent! family of I-Beams \u2190 is a list of these desired? I feel like someone who reads this would want to see what they are and what they do? file system watcher \u2190 is this File System Watcher or file system watcher? Getting started First paragraph slightly confusing This chapter is actually on \"usage\", of which Getting Started is just one part... Set up We can now launch out development environment using \u2190 a screenshot won't hurt The contents of this chapter are not obvious from its title... Converting an Existing Workspace to use Link This section is a tad confused... - Recreating the workspace might be relevant in some section about \"distribution\" SALT to Link what are \"sequence numbers\" ? .dyapp File: APL source file .apl* or .dyalog or configuration file .dcfg . Perhaps link to Configuration file docs as well? Installation Feels like it should be part of Getting Started, although it's really about installing Link if you need a version other than that which ships with the 'terp. Link 2.1 There is some mention about this as the beta name - however, who actually had access to that? I guess technically anyone...","title":"Rich's Notes"},{"location":"RPNotes/#richs-notes","text":"Things which I haven't just directly changed since I'm not exactly sure how yet Sometimes components are referred to by UCMD syntax, sometimes by OOP syntax? Should get consistent... Probably \"API syntax\" followed by \"Also, here is UCMD version\"... the fact that help can be got with ]Link.FnName -? should probably be mentioned somewhere","title":"Rich's Notes"},{"location":"RPNotes/#technical-apl-jargon-which-needs-clarifying-in-a-separate-document","text":"Active workspace The active workspace is the collection of names in an active Dyalog session. It consists of all of the names found using #.\u2395NL\u23739 , and possibly also #.\u2395SE .","title":"Technical APL jargon which needs clarifying in a separate document"},{"location":"RPNotes/#simplified","text":"There are 3 ways to bring code in to or push code out from the active workspace. 1. Use Link.Create to create a bi-directional link. Changes made in the Dyalog editor are reflected in the text source on the file system, and changes made to the text source on the file system are reflected in the active workspace (viewable using the Dyalog editor). 1. Use Link.Import to import code from text source in a folder on the file system into a namespace in the active workspace. 1. Use Link.Export to export code from a namespace in the active workspace to a folder of text source files on the file system. It seems obvious, but somewhere it might be worth noting that - until/unless this is added as a specific feature - individual items can be written to file (\"exported\") by copying them into a new namespace and using Link.Export on that namespace.","title":"Simplified"},{"location":"RPNotes/#scm-for-aplers","text":"This should be its own document, or possibliy repository","title":"SCM for APLers"},{"location":"RPNotes/#introduction","text":"Source code stored in external files is preserved exactly as typed, rather than being reconstructed from the tokenised form. This part is a little obtuse unless you already know about how Dyalog handles source code. It should probably be moved from this section and explained a little further, possibly in the History of Text Source section SCM for APLers should be its own document living somewhere in the Documentation/Learning materials/Information Ecosystem You can invoke ]LINK.Createseveral times to create multiple links, and you can also use ]LINK.Importor ]LINK.Export to import source code into the workspace or export code to external files without creating links that will respond to subsequent changes. This part should be more prominent somehow How do I import code and my changes not be saved? How can I make changes to my code without them being saved?","title":"Introduction"},{"location":"RPNotes/#tech-details","text":"Scripted namespaces: It is likely that this restriction will be lifted in a future version of Link. Once again mentioning the loss of text source fidelity. Should be explained somewhere else or linked to a more comprehensive explanation and some examples Maybe remove - because the APL interpreter does not have a source form for such items. With the exception of the scenarios \u2190 this paragraph needs small rework","title":"Tech details"},{"location":"RPNotes/#how-does-link-work","text":"This section is really part of Technical Details and Limitations, but might... - version 3.0 only uses this for links with an endpoint in \u2395SE . \u2190 is this a change history issue? - It is expected that the APL language engine will support \u2190 Future stuff - will be able to run in the background and \u2190 what does \"in the background\" mean specifically? The fact that Link only acts automatically in response to changes made in editors should be made more prominent! family of I-Beams \u2190 is a list of these desired? I feel like someone who reads this would want to see what they are and what they do? file system watcher \u2190 is this File System Watcher or file system watcher?","title":"How does Link work?"},{"location":"RPNotes/#getting-started","text":"First paragraph slightly confusing This chapter is actually on \"usage\", of which Getting Started is just one part...","title":"Getting started"},{"location":"RPNotes/#set-up","text":"We can now launch out development environment using \u2190 a screenshot won't hurt The contents of this chapter are not obvious from its title...","title":"Set up"},{"location":"RPNotes/#converting-an-existing-workspace-to-use-link","text":"This section is a tad confused... - Recreating the workspace might be relevant in some section about \"distribution\"","title":"Converting an Existing Workspace to use Link"},{"location":"RPNotes/#salt-to-link","text":"what are \"sequence numbers\" ? .dyapp File: APL source file .apl* or .dyalog or configuration file .dcfg . Perhaps link to Configuration file docs as well?","title":"SALT to Link"},{"location":"RPNotes/#installation","text":"Feels like it should be part of Getting Started, although it's really about installing Link if you need a version other than that which ships with the 'terp.","title":"Installation"},{"location":"RPNotes/#link-21","text":"There is some mention about this as the beta name - however, who actually had access to that? I guess technically anyone...","title":"Link 2.1"},{"location":"ReleaseNotes40/","text":"Version 4.0 Release Notes Note This page describes differences between Link version 3.0 and 4.0. Change history for earlier releases, and instructions on migrating to Link from SALT, can be found in the Link version 3.0 documentation . Link version 4.0 is distributed with Dyalog APL version 19.0 and can be used with version 18.2. For instructions on using Link 4.0 with APL version 18.2, see the installation instructions . This page describes the most important enhancements to Link, delivered in version 4.0. For a complete list of changes, see the version 4.0 milestone on GitHub . New Features The following features have been implemented: Configuration files : A user configuration file for recording preferences that apply to all links, for example link creation options like -watch= Directory configuration files store options that should be re-applied when the directory is subsequently linked, including stop and trace settings If you are investigating problems in Link, you can turn off error trapping within Link API functions, or receive notification in the APL session each time Link performs an action related to external files. Note Link.Create, Import and Export have a new switch -ignoreconfig, which allows you to ignore a damaged or otherwise inappropriate configuration file. Creating a Link from single class or namespace files in addition to linking directories. Note that configuration files cannot be created for single-file links Link.Create, Import and Export will default to the current namespace if no namespace is specified. For example, )cs # ]link.export /tmp/myapp ... will export everything in the current workspace to a folder called /tmp/myapp . Link.Create and Import will search the Dyalog Library folders and user folder specified using DYALOG_LIB_PATH for source files. Specifying the file extension is not required, if there is no ambiguity. For example, ]link.import HttpCommand Imported: #.HttpCommand \u2190 C:\\Program Files\\Dyalog\\Dyalog APL-64 19.0 Unicode\\Library\\Conga\\HttpCommand.dyalog Multi-line character data stored in character vectors, character matrices, and vectors of character vectors can optionally be stored in plain text files (as opposed to using APL Array Notation). See Array Formats for more information. When defining functions or operators in the active workspace, Link.Create will update information about the most recent change using file information reported by the operating system. This information is reported by \u2395AT , 20 21 22 \u2395ATX , and the Workspace Explorer. Note This is not the information that would be reported by a source code management system like Git - you need to use a Git, SVN or similar client to view more detailed information about changes to the source. Link.Add can evaluate an expression and assign to items before the items are added to the workspace. ]link.add name\u2190expression Deferred Features The following features were originally in the Link 4.0 milestone, but have been moved to Link 5.0, which will be developed early in 2024. The so-called crawler, which will periodically scan for differences between the active workspace and the linked source files, will be implemented immediately after the release of Link 4.0. This feature will detect changes made to the workspace using other mechanisms than the editor, and also make Link independent of having a file system watcher available. Using a .linkignore file to list names in the active workspace which should be ignored by Link and in particular the crawler. The ability to re-establish broken links.","title":"Version 4.0 Release Notes"},{"location":"ReleaseNotes40/#version-40-release-notes","text":"Note This page describes differences between Link version 3.0 and 4.0. Change history for earlier releases, and instructions on migrating to Link from SALT, can be found in the Link version 3.0 documentation . Link version 4.0 is distributed with Dyalog APL version 19.0 and can be used with version 18.2. For instructions on using Link 4.0 with APL version 18.2, see the installation instructions . This page describes the most important enhancements to Link, delivered in version 4.0. For a complete list of changes, see the version 4.0 milestone on GitHub .","title":"Version 4.0 Release Notes"},{"location":"ReleaseNotes40/#new-features","text":"The following features have been implemented: Configuration files : A user configuration file for recording preferences that apply to all links, for example link creation options like -watch= Directory configuration files store options that should be re-applied when the directory is subsequently linked, including stop and trace settings If you are investigating problems in Link, you can turn off error trapping within Link API functions, or receive notification in the APL session each time Link performs an action related to external files. Note Link.Create, Import and Export have a new switch -ignoreconfig, which allows you to ignore a damaged or otherwise inappropriate configuration file. Creating a Link from single class or namespace files in addition to linking directories. Note that configuration files cannot be created for single-file links Link.Create, Import and Export will default to the current namespace if no namespace is specified. For example, )cs # ]link.export /tmp/myapp ... will export everything in the current workspace to a folder called /tmp/myapp . Link.Create and Import will search the Dyalog Library folders and user folder specified using DYALOG_LIB_PATH for source files. Specifying the file extension is not required, if there is no ambiguity. For example, ]link.import HttpCommand Imported: #.HttpCommand \u2190 C:\\Program Files\\Dyalog\\Dyalog APL-64 19.0 Unicode\\Library\\Conga\\HttpCommand.dyalog Multi-line character data stored in character vectors, character matrices, and vectors of character vectors can optionally be stored in plain text files (as opposed to using APL Array Notation). See Array Formats for more information. When defining functions or operators in the active workspace, Link.Create will update information about the most recent change using file information reported by the operating system. This information is reported by \u2395AT , 20 21 22 \u2395ATX , and the Workspace Explorer. Note This is not the information that would be reported by a source code management system like Git - you need to use a Git, SVN or similar client to view more detailed information about changes to the source. Link.Add can evaluate an expression and assign to items before the items are added to the workspace. ]link.add name\u2190expression","title":"New Features"},{"location":"ReleaseNotes40/#deferred-features","text":"The following features were originally in the Link 4.0 milestone, but have been moved to Link 5.0, which will be developed early in 2024. The so-called crawler, which will periodically scan for differences between the active workspace and the linked source files, will be implemented immediately after the release of Link 4.0. This feature will detect changes made to the workspace using other mechanisms than the editor, and also make Link independent of having a file system watcher available. Using a .linkignore file to list names in the active workspace which should be ignored by Link and in particular the crawler. The ability to re-establish broken links.","title":"Deferred Features"},{"location":"API/","text":"API Overview API function syntax The Link API functions all reside in \u2395SE.Link . The general syntax for Link API functions is as follows: message \u2190 options \u2395SE.Link.FnName args where: message is a simple character vector or nested array containing messages related to the effects of the function call. options is a namespace containing optional parameters . Only certain functions accept an options namespace. FnName is the name of the API function args is either a character vector or a nested vector as described in the help section for that API function. Option Namespaces Some API functions accept an option namespace as the left argument. For example, to create a link with non-default source and flatten options, you would write: options\u2190\u2395NS \u236c \u235d create empty namespace options.(source flatten)\u2190'dir' 1 \u235d set two named options options \u2395SE.Link.Create 'myapp' '/sources/myapp' \u235d namespace and director name on the right, options on left Creating option namespaces will become more elegant once Dyalog APL is enhanced with a notation for namespaces. Until that time (no definite schedule has yet been set), Link API functions will accept a character vector left argument which represents an array in the proposed Literal Array Notation , for example: '(source:''dir'' \u22c4 flatten:1)' \u2395SE.Link.Create 'myapp' '/sources/myapp' User commands Most API functions have a corresponding user command, to make them a little easier to use interactively. The API functions with user command covers are indicated with ] in the function reference tables. These user commands all take exactly the same arguments and options as the API functions, specified using user command syntax. The Link.Create call above would thus be written: ]LINK.Create myapp /sources/myapp -source=dir -flatten Lowercase option names: Although option names are case sensitive and some of them contain uppercase letters when provided to API functions via option namespaces, the user command option names are entirely lowercase, to make interactive use more convenient. Specifying extensions: Two options require arrays identifying file extensions: codeExtensions , customExtensions and typeExtensions . For convenience, the ]LINK.Create user command accepts the name of a variable containing the array, rather than the array values. A list of available user commands can be viewed in the session with ]LINK -? . Help for a particular user command Cmd is displayed using ]LINK.Cmd -? . Basic API Function reference The following functions cover the vast majority of normal use-cases: Function User Command Right Argument(s) Left Argument(s) Result Add ]Add items message Break ]Break namespaces options: all recursive message Configure ]Configure target settings current or previous settings Create ]Create namespace directory options: source watch arrays (and many more ) message Export ]Export namespace directory options: overwrite caseCode arrays sysVars message Expunge ]Expunge items boolean array Import ]Import namespace directory options: overwrite flatten fastLoad message LaunchDir none none directory name Refresh ]Refresh namespace options: source message Resync ]Resync namespace options: proceed arrays sysvars message Status ]Status namespace options: extended message Version version number as string Note The currently active version of Link is reported by \u2395SE.Link.Version and found in the output of ]TOOLS.Version Advanced API Function reference The \"advanced\" functions are typically used when building your own tools on top of Link, rather than simply using Link to maintain the source of an application: Function User Command Right Argument(s) Left Argument(s) Result CaseCode filename <none> case-coded filename Fix source array: namespace name oldname boolean GetFileName ]GetFileName items <none> filenames GetItemName ]GetItemName filenames <none> items Notify event filename oldfilename <none> <none> StripCaseCode filename <none> filename without case code TypeExtension name class option namespace used for Create file extension (without leading '.' )","title":"API Overview"},{"location":"API/#api-overview","text":"","title":"API Overview"},{"location":"API/#api-function-syntax","text":"The Link API functions all reside in \u2395SE.Link . The general syntax for Link API functions is as follows: message \u2190 options \u2395SE.Link.FnName args where: message is a simple character vector or nested array containing messages related to the effects of the function call. options is a namespace containing optional parameters . Only certain functions accept an options namespace. FnName is the name of the API function args is either a character vector or a nested vector as described in the help section for that API function.","title":"API function syntax"},{"location":"API/#option-namespaces","text":"Some API functions accept an option namespace as the left argument. For example, to create a link with non-default source and flatten options, you would write: options\u2190\u2395NS \u236c \u235d create empty namespace options.(source flatten)\u2190'dir' 1 \u235d set two named options options \u2395SE.Link.Create 'myapp' '/sources/myapp' \u235d namespace and director name on the right, options on left Creating option namespaces will become more elegant once Dyalog APL is enhanced with a notation for namespaces. Until that time (no definite schedule has yet been set), Link API functions will accept a character vector left argument which represents an array in the proposed Literal Array Notation , for example: '(source:''dir'' \u22c4 flatten:1)' \u2395SE.Link.Create 'myapp' '/sources/myapp'","title":"Option Namespaces"},{"location":"API/#user-commands","text":"Most API functions have a corresponding user command, to make them a little easier to use interactively. The API functions with user command covers are indicated with ] in the function reference tables. These user commands all take exactly the same arguments and options as the API functions, specified using user command syntax. The Link.Create call above would thus be written: ]LINK.Create myapp /sources/myapp -source=dir -flatten Lowercase option names: Although option names are case sensitive and some of them contain uppercase letters when provided to API functions via option namespaces, the user command option names are entirely lowercase, to make interactive use more convenient. Specifying extensions: Two options require arrays identifying file extensions: codeExtensions , customExtensions and typeExtensions . For convenience, the ]LINK.Create user command accepts the name of a variable containing the array, rather than the array values. A list of available user commands can be viewed in the session with ]LINK -? . Help for a particular user command Cmd is displayed using ]LINK.Cmd -? .","title":"User commands"},{"location":"API/#basic-api-function-reference","text":"The following functions cover the vast majority of normal use-cases: Function User Command Right Argument(s) Left Argument(s) Result Add ]Add items message Break ]Break namespaces options: all recursive message Configure ]Configure target settings current or previous settings Create ]Create namespace directory options: source watch arrays (and many more ) message Export ]Export namespace directory options: overwrite caseCode arrays sysVars message Expunge ]Expunge items boolean array Import ]Import namespace directory options: overwrite flatten fastLoad message LaunchDir none none directory name Refresh ]Refresh namespace options: source message Resync ]Resync namespace options: proceed arrays sysvars message Status ]Status namespace options: extended message Version version number as string Note The currently active version of Link is reported by \u2395SE.Link.Version and found in the output of ]TOOLS.Version","title":"Basic API Function reference"},{"location":"API/#advanced-api-function-reference","text":"The \"advanced\" functions are typically used when building your own tools on top of Link, rather than simply using Link to maintain the source of an application: Function User Command Right Argument(s) Left Argument(s) Result CaseCode filename <none> case-coded filename Fix source array: namespace name oldname boolean GetFileName ]GetFileName items <none> filenames GetItemName ]GetItemName filenames <none> items Notify event filename oldfilename <none> <none> StripCaseCode filename <none> filename without case code TypeExtension name class option namespace used for Create file extension (without leading '.' )","title":"Advanced API Function reference"},{"location":"API/Link.Add/","text":"Link.Add Syntax ]LINK.Add name\u2190expression message \u2190 \u2395SE.Link.Add name\u2190expression Show User Command information in the session with ]LINK.Add -? This function allows you to add one or more APL items to the link, creating the appropriate representation in the linked directory. New in 4.0 is that you can evaluate an expression and assign the result into the items before ]LINK.Add is run. Note that a source file will only be created or updated if the item is in a linked namespace. This is useful to write a new or modified array to a source file: arrays are normally not written to file by Link . It is also useful when a change has been made to a linked item using any mechanism other than the APL editor, for example the definition of a new dfn using assignment, or the use of )COPY to bring new objects into the workspace. Note You can create or update an item from source while adding it to the Link by calling Link.Fix . Arguments name is a simple character vector or nested vector of character vectors containing the names of items to be added to the link. In the user command, <name> is a space-separated list of names. expression is an expression that is evaluated and assigned to the single or list of items before ]LINK.ADD takes affect. That is, that the expression is not saved, but the result of it is. Result message is a simple character vector describing items that were: Added (they belong in a linked namespace and were successfully added) Not linked (they do not belong to a linked namespace) Not found (the name doesn't exist at all)","title":"Link.Add"},{"location":"API/Link.Add/#linkadd","text":"","title":"Link.Add"},{"location":"API/Link.Add/#syntax","text":"]LINK.Add name\u2190expression message \u2190 \u2395SE.Link.Add name\u2190expression Show User Command information in the session with ]LINK.Add -? This function allows you to add one or more APL items to the link, creating the appropriate representation in the linked directory. New in 4.0 is that you can evaluate an expression and assign the result into the items before ]LINK.Add is run. Note that a source file will only be created or updated if the item is in a linked namespace. This is useful to write a new or modified array to a source file: arrays are normally not written to file by Link . It is also useful when a change has been made to a linked item using any mechanism other than the APL editor, for example the definition of a new dfn using assignment, or the use of )COPY to bring new objects into the workspace. Note You can create or update an item from source while adding it to the Link by calling Link.Fix .","title":"Syntax"},{"location":"API/Link.Add/#arguments","text":"name is a simple character vector or nested vector of character vectors containing the names of items to be added to the link. In the user command, <name> is a space-separated list of names. expression is an expression that is evaluated and assigned to the single or list of items before ]LINK.ADD takes affect. That is, that the expression is not saved, but the result of it is.","title":"Arguments"},{"location":"API/Link.Add/#result","text":"message is a simple character vector describing items that were: Added (they belong in a linked namespace and were successfully added) Not linked (they do not belong to a linked namespace) Not found (the name doesn't exist at all)","title":"Result"},{"location":"API/Link.Break/","text":"Link.Break ]LINK.Break [<ns>] [-all={#|\u2395SE|*}] [-recursive={on|off|error}] message \u2190 {options} \u2395SE.Link.Break namespace Show User Command information in the session with ]LINK.Break -? Breaks an existing link: Does not affect the contents of the active workspace except to remove all traces of the link, preventing any further synchronisation from taking place. Note If you have enabled Pause Threads on Error and you have an application thread running which encounters an error, Link.Break can hang when the thread which is created to shut down the file system watcher becomes paused. If this happens, use IDE menu items to resume execution. Arguments namespace is a list of namespace names as character vectors or references In the user command, <ns> is a space-separated list of namespace names Options all { # |\u2395SE|* } By default ( -all or -all=# ), break links to all namespaces within the main workspace. To break links to namespaces in the session space, use -all=\u2395SE , and to break absolutely all links, -all=* . Note that the list of namespaces is ignored when -all is used. recursive {on|off| error } Break child namespaces too if they have separately defined links. Result message is a simple character vector describing namespaces that were: - effectively unlinked - not linked in the first place - not found","title":"Link.Break"},{"location":"API/Link.Break/#linkbreak","text":"]LINK.Break [<ns>] [-all={#|\u2395SE|*}] [-recursive={on|off|error}] message \u2190 {options} \u2395SE.Link.Break namespace Show User Command information in the session with ]LINK.Break -? Breaks an existing link: Does not affect the contents of the active workspace except to remove all traces of the link, preventing any further synchronisation from taking place. Note If you have enabled Pause Threads on Error and you have an application thread running which encounters an error, Link.Break can hang when the thread which is created to shut down the file system watcher becomes paused. If this happens, use IDE menu items to resume execution.","title":"Link.Break"},{"location":"API/Link.Break/#arguments","text":"namespace is a list of namespace names as character vectors or references In the user command, <ns> is a space-separated list of namespace names","title":"Arguments"},{"location":"API/Link.Break/#options","text":"","title":"Options"},{"location":"API/Link.Break/#all","text":"{ # |\u2395SE|* } By default ( -all or -all=# ), break links to all namespaces within the main workspace. To break links to namespaces in the session space, use -all=\u2395SE , and to break absolutely all links, -all=* . Note that the list of namespaces is ignored when -all is used.","title":"all"},{"location":"API/Link.Break/#recursive","text":"{on|off| error } Break child namespaces too if they have separately defined links.","title":"recursive"},{"location":"API/Link.Break/#result","text":"message is a simple character vector describing namespaces that were: - effectively unlinked - not linked in the first place - not found","title":"Result"},{"location":"API/Link.CaseCode/","text":"Link.CaseCode names \u2190 {options} \u2395SE.Link.CaseCode filenames The CaseCode function adds case coding to any file name. It is intended for use in functions which implement getFilename callbacks, which you can set up when you create a Link , to allow your code to generate file names. If case coding is enabled for the repository, the file name should be correctly case coded. For example, if /tmp is a currently linked folder: \u2395SE.Link.CaseCode 'c:\\tmp\\HelloWorld.apln' 'c:\\tmp\\FOO.aplf' c:/tmp/HelloWorld-41.apln c:/tmp/FOO-7.aplf What is a \"case code\"? A reverse binary indication of the letter cases in the main part of the name, encoded in octal. For example HelloWorld \u2003has the uppercase indication 1000010000 \u2003which when reversed is 0000100001 \u2003which is binary for 33 10 \u2003which in octal is 41 8 \u2003so the full name including case code is HelloWorld-41 Arguments filenames is a simple character vector or vector of character vectors containing file names which do not contain case codes. The file names do not need to exist, but they need to reference a currently linked folder. Result Case coded file name(s)","title":"Link.CaseCode"},{"location":"API/Link.CaseCode/#linkcasecode","text":"names \u2190 {options} \u2395SE.Link.CaseCode filenames The CaseCode function adds case coding to any file name. It is intended for use in functions which implement getFilename callbacks, which you can set up when you create a Link , to allow your code to generate file names. If case coding is enabled for the repository, the file name should be correctly case coded. For example, if /tmp is a currently linked folder: \u2395SE.Link.CaseCode 'c:\\tmp\\HelloWorld.apln' 'c:\\tmp\\FOO.aplf' c:/tmp/HelloWorld-41.apln c:/tmp/FOO-7.aplf","title":"Link.CaseCode"},{"location":"API/Link.CaseCode/#what-is-a-case-code","text":"A reverse binary indication of the letter cases in the main part of the name, encoded in octal. For example HelloWorld \u2003has the uppercase indication 1000010000 \u2003which when reversed is 0000100001 \u2003which is binary for 33 10 \u2003which in octal is 41 8 \u2003so the full name including case code is HelloWorld-41","title":"What is a \"case code\"?"},{"location":"API/Link.CaseCode/#arguments","text":"filenames is a simple character vector or vector of character vectors containing file names which do not contain case codes. The file names do not need to exist, but they need to reference a currently linked folder.","title":"Arguments"},{"location":"API/Link.CaseCode/#result","text":"Case coded file name(s)","title":"Result"},{"location":"API/Link.Configure/","text":"Link.Configure Syntax ]LINK.Configure <target> [settings] message \u2190 \u2395SE.Link.Configure target [settings] Show User Command information in the session with ]LINK.Configure -? Arguments target can be * to refer to the user configuration. It can be a reference to, or a simple character vector containing the name of a namespace. Finally, it can be the full name of a configuration file. settings is a list in the form name:value , providing new values for configuration settings. If no value is provided (there is nothing following the colon), the setting is deleted from the corresponding configuration file. Result If no settings were provided, Configure returns a formatted display of the current contents of the configuration file. Otherwise, it returns the previous values for any settings mentioned in the argument.","title":"Link.Configure"},{"location":"API/Link.Configure/#linkconfigure","text":"","title":"Link.Configure"},{"location":"API/Link.Configure/#syntax","text":"]LINK.Configure <target> [settings] message \u2190 \u2395SE.Link.Configure target [settings] Show User Command information in the session with ]LINK.Configure -?","title":"Syntax"},{"location":"API/Link.Configure/#arguments","text":"target can be * to refer to the user configuration. It can be a reference to, or a simple character vector containing the name of a namespace. Finally, it can be the full name of a configuration file. settings is a list in the form name:value , providing new values for configuration settings. If no value is provided (there is nothing following the colon), the setting is deleted from the corresponding configuration file.","title":"Arguments"},{"location":"API/Link.Configure/#result","text":"If no settings were provided, Configure returns a formatted display of the current contents of the configuration file. Otherwise, it returns the previous values for any settings mentioned in the argument.","title":"Result"},{"location":"API/Link.Create/","text":"Link.Create Syntax ]LINK.Create [ns] <dirorfile> [-source={ns|dir|auto}] [-watch={none|ns|dir|both}] [-casecode] [-forceextensions] [-forcefilenames] [-arrays] [-sysvars] [-flatten] [-beforeread=<fn>] [-beforewrite=<fn>] [-getfilename=<fn>] [-codeextensions=<var>] [-typeextensions=<var>] [-fastload] [-ignoreconfig] [-text={aplan|plain}] message \u2190 {options} \u2395SE.Link.Create (namespace directory) Show User Command information in the session with ]LINK.Create -? Arguments namespace is optional; if it is not provided, -source=dir is implied and a link with the name of the directory being linked to will be created within the current namespace. If provided, it must be a reference to, or a simple character vector containing the name of a namespace. Note that if a reference is used, it must refer to a namespace which has a display form which has name class 9 and can be used to locate the namespace. Links can not be created to \"anonymous\" spaces with names containing [namespace] or similar segments. dirorfile is a simple character vector containing the path to a file system directory (without a trailing backslash), or a single text file defining a namespace, class or interface. Result message is a simple character vector describing the established link, along with possible failures If namespace is # and the current workspace is isn't associated with a file ( \u2395WSID\u2261'CLEAR WS' ) then \u2395WSID will be set to directory . The value will be with a trailing slash or backslash to prevent being mistaken for a file name. The default titlebar caption of RIDE and the Windows IDE can then be used to keep track of which session is linked to which directory and a custom titlebar captions can use the {WSID} tag to include the value. Common options source Default: auto The source option specifies whether to consider the namespace in the active workspace (ns) or directory on the file system (dir) as the source (also used by a subsequent Refresh ). source is a simple character vector, one of 'ns' , 'dir' or 'auto' . From Link version 4.0, a file name can be used to load a namespace, class or interface from a single file, but dir is still used in this case. dir means that the namespace must be non-existent or empty and will be populated from source files. ns means that the directory must be non-existent or empty and will be populated by source files for the items in the namespace. auto will use whichever of ns or dir that is not empty. If both are empty, it will use dir on a subsequent Refresh . watch Default: both if a file system watcher can be created, else ns The watch option specifies which sides of the link to watch for changes (and synchronise). Watching a dir (or both ) is currently only supported using the .NET Framework or .NET Core. watch is a simple character vector, one of 'none' , 'ns' , 'dir' or 'both' . none: changes are not automatically propagated across the link in either direction. ns: changes made in a linked namespace changes (made with the editor) will be copied to files. Note that it will not reflect changes made using other mechanisms, such as assignment, \u2395FX , \u2395FIX , \u2395CY , or \u2395NS . If you want to programmatically change an item so that the change is reflected to files, you should use \u2395SE.Link.Fix . dir will mirror changes made to files (using any mechanism) into the linked namespace. Note that there is a chance that updating a large number of files (e.g. git checkout, git pull or an unzip) may cause the file system watcher to miss changes and not report them to Link. If the source files are on a network drive, the file system watcher may be even more unreliable. Use \u2395SE.Link.Resync if you suspect something is wrong. both will synchronise changes in both directions. This is the default, and is recommended except in very special circumstances. Note Link.Refresh can be used to force a wholesale update of everything based on the setting of the -source option, and Link.Resync can always be used to generate a list of differences between the workspace and linked directories if you are in doubt about the current state. arrays Default: off The arrays flag will export arrays on link creation. if simply set ( options.arrays\u21901 for the function or -arrays for the user command), then all arrays are exported. if set to a comma-separated list of names ( options.arrays\u2190'name1,name2,...' for the function or -arrays=name1,name2,... for the user command) then arrays with specified names are exported. This option takes effect only when source is ns , and only when the link is initially created. sysVars Default: off The sysVars flag will export namespace-scoped system variables to file. The exhaustive list of exported variables is: \u2395AVU \u2395CT \u2395DCT \u2395DIV \u2395FR \u2395IO \u2395ML \u2395PP \u2395RL \u2395RTL \u2395USING \u2395WX . They will be exported for all unscripted namespaces. This option takes effect only when source is ns . forceExtensions Default: off The forceExtensions flag forces correct file extensions. If enabled, file extensions will be adjusted (if necessary), when an item is defined in the workspace from an external file, so that the file extension accurately reflects the type of the item according to typeExtensions . forceFilenames Default: off The forceFilenames flag will force correct file names. If enabled, file names will be adjusted so that they match the item name, when an item is defined in the workspace from an external file, so that the file name matches the name of the item. By default, Link will always create new files with the same name as items created in the active workspace. However, it will not insist that file names match item names when importing items from a directory. If forceFilenames is not set. Link will update to the same file that an item was loaded from, even though the file name does not match the item name. Advanced Options ignoreconfig Default: off The ignoreconfig allows you to ignore the .linkconfig file in the linked directory. This can be useful during debugging, especially if you have a damaged configuration file. flatten Default: off The flatten flag prevents the creation of sub-namespaces in the active workspace. The flatten option will load all items into the root of the linked namespace, even if the source code is arranged into sub-directories. This is typically used for applications that have source which is divided into modules, but still expects to run in a \"flat\" workspace. Note that if flatten is set, newly created items need special treatment: If a function or operator is renamed in the editor, the new item will be placed in the same folder as the original item. If a new item is created, it will be placed in the root of the linked directory. It is also possible to use the getFilename setting to add application-specific logic to determine the file name to be used (or prompt the user for a decision). A suggested workflow is to always create a stub source file in the correct directory and edit the function that appears in the workspace, rather than creating new functions in the workspace. This option takes effect only when source is dir . caseCode Default: off The caseCode flag adds a suffix to file names on write. If your application contains items with names that differ only in case (for example Debug and DEBUG ), and your file system is case-insensitive (for example, under Microsoft Windows), then enabling caseCode will cause a suffix to be added to file names, containing an octal encoding of the location of uppercase letters in the name. For example, with caseCode on, two functions named Debug and DEBUG will be written to files named Debug-1.aplf and DEBUG-37.aplf . Note Dyalog recommends that you avoid creating systems with names that differ only in case. This feature primarily exists to support the import of applications which already use such names. You will probably also want to enable forceFilenames if you enable caseCode . beforeWrite If you specify a beforeWrite function, it will be called before Link updates a file or directory, allowing support of custom code or data formats. beforeWrite is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -beforeWrite=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ('beforeWrite') [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to write to (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to write [5] Name class of the APL item to write [6] Old APL name (different from APL name if the write is due to a rename) [7] Source code that Link intends to write to file Note Do not assume a specific length, more elements may be added in the future. Your callback function must return one of the following results: 0 : The beforeWrite function has completed all necessary actions. Link should not update any files. 1 : The beforeWrite function wishes to \"pass\" on this write: Link should proceed as planned. beforeRead If you specify a beforeRead function, it will be called before Link reads source from a file or directory, allowing support of custom code or data formats. beforeRead is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -beforeRead=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ( 'beforeRead' ) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to read from (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to update [5] Name class of the APL item to be read Note Do not assume a specific length, more elements may be added in the future. Your callback function must return one of the following results: - 0 : The beforeRead function has completed all necessary actions. Link should not update the workspace. - 1 : The beforeRead function wishes to \"pass\" on this read: Link should proceed as planned. getFilename If you specify a getFilename function, it will be called before Link updates a file or directory, allowing you to modify the name (or more likely the extension) of the file used to store the source for an APL item. Changing the file name this way allows you to override the caseCode , forceFilenames and forceExtensions options. getFilename is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -getFilename=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ( 'getFilename' ) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to use (directories end with a slash) [4] Fully qualified APL name of the item [5] Name class of the APL item [6] Old APL name (different from APL name if the write is due to a rename) Note Do not assume a specific length, more elements may be added in the future. Your callback function must return a simple character vector which must be one of: empty: to signify that Link should proceed with the suggested file name. non-empty: to specify the name to be used. codeExtensions Default: 'aplf' 'aplo' 'apln' 'aplc' 'apli' 'dyalog' 'apl' 'mipage' Specify file extensions that are expected to contain source code. Link will only process changes to files with the specified extensions. var is a nested vector of character vectors. From a user command, the syntax is -codeExtensions=var where var holds the expected vector of extensions. customExtensions Default: '' \u235d an empty character vector meaning no custom extensions Specifies additional file extensions handled by beforeRead functions. customExtensions is a nested vector of character vectors. From a user command, the syntax is -customExtensions=var where var holds the expected vector. If you have specified a beforeRead handler function, and your code supports the use of custom file extensions to store source data in application-specific formats, you need to set customExtensions so that Link does not ignore changes to these file types. The reason for splitting the list of extensions into two parts ( codeExtensions and customExtensions ) is to avoid your code having to repeat the list of standard extensions, or update this list if it should be extended in the future. typeExtensions Default: 6 2\u23742 'apla' 3 'aplf' 4 'aplo' 9.1 'apln' 9.4 'aplc' 9.5 'apli' The typeExtensions table specifies the default extension that should be used when creating a new file to contain the source for an item of a given type. typeExtensions is a two-column matrix with numeric name class numbers in the first column and character vectors of corresponding file extensions in the second column. Note that, although you can change the extensions used, Link will add default definitions for any of the types that you do not specify. For example, if you do not include a row for type 9.5, Link will use 'apli' for interfaces. From a user command, the syntax is -typeExtensions=var where var holds the expected array. Note that the forceExtensions switch can be used to correct all extensions on pre-existing files when a link is created. The default corresponds to: Type extension 2 apla 3 aplf 4 aplo 9.1 apln 9.4 aplc 9.5 apli fastLoad Default: off The fastload flag will reduce the load time by not inspecting the source to detect name clashes. This affects only initial directory loading, but not subsequent editor or file system watcher events. It is worth setting fastLoad for very large projects that don't produce name clashes (that is, two files defining the same APL name). Side effects are (again, only at initial load time, not at subsequent events): good: load will be significantly faster because files won't be inspected to determine their true APL name. bad: clashing names won't be detected: files may silently overwrite each other's APL definition if they define the same APL name. bad: forceFilenames / forceExtensions won't be observed bad: beforeRead may report incorrect name class This option takes effect only when source is dir . ignoreconfig Default: off Ignores any Link configuration files. See Configuration Files for details. text Default: aplan Chooses whether plain text arrays are stored using APL Array Notation (APLAN) or as plain text files. text is a simple character vector and must be either 'aplan' or 'plain' . See Array Formats for details.","title":"Link.Create"},{"location":"API/Link.Create/#linkcreate","text":"","title":"Link.Create"},{"location":"API/Link.Create/#syntax","text":"]LINK.Create [ns] <dirorfile> [-source={ns|dir|auto}] [-watch={none|ns|dir|both}] [-casecode] [-forceextensions] [-forcefilenames] [-arrays] [-sysvars] [-flatten] [-beforeread=<fn>] [-beforewrite=<fn>] [-getfilename=<fn>] [-codeextensions=<var>] [-typeextensions=<var>] [-fastload] [-ignoreconfig] [-text={aplan|plain}] message \u2190 {options} \u2395SE.Link.Create (namespace directory) Show User Command information in the session with ]LINK.Create -?","title":"Syntax"},{"location":"API/Link.Create/#arguments","text":"namespace is optional; if it is not provided, -source=dir is implied and a link with the name of the directory being linked to will be created within the current namespace. If provided, it must be a reference to, or a simple character vector containing the name of a namespace. Note that if a reference is used, it must refer to a namespace which has a display form which has name class 9 and can be used to locate the namespace. Links can not be created to \"anonymous\" spaces with names containing [namespace] or similar segments. dirorfile is a simple character vector containing the path to a file system directory (without a trailing backslash), or a single text file defining a namespace, class or interface.","title":"Arguments"},{"location":"API/Link.Create/#result","text":"message is a simple character vector describing the established link, along with possible failures If namespace is # and the current workspace is isn't associated with a file ( \u2395WSID\u2261'CLEAR WS' ) then \u2395WSID will be set to directory . The value will be with a trailing slash or backslash to prevent being mistaken for a file name. The default titlebar caption of RIDE and the Windows IDE can then be used to keep track of which session is linked to which directory and a custom titlebar captions can use the {WSID} tag to include the value.","title":"Result"},{"location":"API/Link.Create/#common-options","text":"","title":"Common options"},{"location":"API/Link.Create/#source","text":"Default: auto The source option specifies whether to consider the namespace in the active workspace (ns) or directory on the file system (dir) as the source (also used by a subsequent Refresh ). source is a simple character vector, one of 'ns' , 'dir' or 'auto' . From Link version 4.0, a file name can be used to load a namespace, class or interface from a single file, but dir is still used in this case. dir means that the namespace must be non-existent or empty and will be populated from source files. ns means that the directory must be non-existent or empty and will be populated by source files for the items in the namespace. auto will use whichever of ns or dir that is not empty. If both are empty, it will use dir on a subsequent Refresh .","title":"source"},{"location":"API/Link.Create/#watch","text":"Default: both if a file system watcher can be created, else ns The watch option specifies which sides of the link to watch for changes (and synchronise). Watching a dir (or both ) is currently only supported using the .NET Framework or .NET Core. watch is a simple character vector, one of 'none' , 'ns' , 'dir' or 'both' . none: changes are not automatically propagated across the link in either direction. ns: changes made in a linked namespace changes (made with the editor) will be copied to files. Note that it will not reflect changes made using other mechanisms, such as assignment, \u2395FX , \u2395FIX , \u2395CY , or \u2395NS . If you want to programmatically change an item so that the change is reflected to files, you should use \u2395SE.Link.Fix . dir will mirror changes made to files (using any mechanism) into the linked namespace. Note that there is a chance that updating a large number of files (e.g. git checkout, git pull or an unzip) may cause the file system watcher to miss changes and not report them to Link. If the source files are on a network drive, the file system watcher may be even more unreliable. Use \u2395SE.Link.Resync if you suspect something is wrong. both will synchronise changes in both directions. This is the default, and is recommended except in very special circumstances. Note Link.Refresh can be used to force a wholesale update of everything based on the setting of the -source option, and Link.Resync can always be used to generate a list of differences between the workspace and linked directories if you are in doubt about the current state.","title":"watch"},{"location":"API/Link.Create/#arrays","text":"Default: off The arrays flag will export arrays on link creation. if simply set ( options.arrays\u21901 for the function or -arrays for the user command), then all arrays are exported. if set to a comma-separated list of names ( options.arrays\u2190'name1,name2,...' for the function or -arrays=name1,name2,... for the user command) then arrays with specified names are exported. This option takes effect only when source is ns , and only when the link is initially created.","title":"arrays"},{"location":"API/Link.Create/#sysvars","text":"Default: off The sysVars flag will export namespace-scoped system variables to file. The exhaustive list of exported variables is: \u2395AVU \u2395CT \u2395DCT \u2395DIV \u2395FR \u2395IO \u2395ML \u2395PP \u2395RL \u2395RTL \u2395USING \u2395WX . They will be exported for all unscripted namespaces. This option takes effect only when source is ns .","title":"sysVars"},{"location":"API/Link.Create/#forceextensions","text":"Default: off The forceExtensions flag forces correct file extensions. If enabled, file extensions will be adjusted (if necessary), when an item is defined in the workspace from an external file, so that the file extension accurately reflects the type of the item according to typeExtensions .","title":"forceExtensions"},{"location":"API/Link.Create/#forcefilenames","text":"Default: off The forceFilenames flag will force correct file names. If enabled, file names will be adjusted so that they match the item name, when an item is defined in the workspace from an external file, so that the file name matches the name of the item. By default, Link will always create new files with the same name as items created in the active workspace. However, it will not insist that file names match item names when importing items from a directory. If forceFilenames is not set. Link will update to the same file that an item was loaded from, even though the file name does not match the item name.","title":"forceFilenames"},{"location":"API/Link.Create/#advanced-options","text":"","title":"Advanced Options"},{"location":"API/Link.Create/#ignoreconfig","text":"Default: off The ignoreconfig allows you to ignore the .linkconfig file in the linked directory. This can be useful during debugging, especially if you have a damaged configuration file.","title":"ignoreconfig"},{"location":"API/Link.Create/#flatten","text":"Default: off The flatten flag prevents the creation of sub-namespaces in the active workspace. The flatten option will load all items into the root of the linked namespace, even if the source code is arranged into sub-directories. This is typically used for applications that have source which is divided into modules, but still expects to run in a \"flat\" workspace. Note that if flatten is set, newly created items need special treatment: If a function or operator is renamed in the editor, the new item will be placed in the same folder as the original item. If a new item is created, it will be placed in the root of the linked directory. It is also possible to use the getFilename setting to add application-specific logic to determine the file name to be used (or prompt the user for a decision). A suggested workflow is to always create a stub source file in the correct directory and edit the function that appears in the workspace, rather than creating new functions in the workspace. This option takes effect only when source is dir .","title":"flatten"},{"location":"API/Link.Create/#casecode","text":"Default: off The caseCode flag adds a suffix to file names on write. If your application contains items with names that differ only in case (for example Debug and DEBUG ), and your file system is case-insensitive (for example, under Microsoft Windows), then enabling caseCode will cause a suffix to be added to file names, containing an octal encoding of the location of uppercase letters in the name. For example, with caseCode on, two functions named Debug and DEBUG will be written to files named Debug-1.aplf and DEBUG-37.aplf . Note Dyalog recommends that you avoid creating systems with names that differ only in case. This feature primarily exists to support the import of applications which already use such names. You will probably also want to enable forceFilenames if you enable caseCode .","title":"caseCode"},{"location":"API/Link.Create/#beforewrite","text":"If you specify a beforeWrite function, it will be called before Link updates a file or directory, allowing support of custom code or data formats. beforeWrite is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -beforeWrite=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ('beforeWrite') [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to write to (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to write [5] Name class of the APL item to write [6] Old APL name (different from APL name if the write is due to a rename) [7] Source code that Link intends to write to file Note Do not assume a specific length, more elements may be added in the future. Your callback function must return one of the following results: 0 : The beforeWrite function has completed all necessary actions. Link should not update any files. 1 : The beforeWrite function wishes to \"pass\" on this write: Link should proceed as planned.","title":"beforeWrite"},{"location":"API/Link.Create/#beforeread","text":"If you specify a beforeRead function, it will be called before Link reads source from a file or directory, allowing support of custom code or data formats. beforeRead is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -beforeRead=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ( 'beforeRead' ) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to read from (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to update [5] Name class of the APL item to be read Note Do not assume a specific length, more elements may be added in the future. Your callback function must return one of the following results: - 0 : The beforeRead function has completed all necessary actions. Link should not update the workspace. - 1 : The beforeRead function wishes to \"pass\" on this read: Link should proceed as planned.","title":"beforeRead"},{"location":"API/Link.Create/#getfilename","text":"If you specify a getFilename function, it will be called before Link updates a file or directory, allowing you to modify the name (or more likely the extension) of the file used to store the source for an APL item. Changing the file name this way allows you to override the caseCode , forceFilenames and forceExtensions options. getFilename is a simple character vector containing the name of a function relative to the linked namespace. In the user command, simply give the name. For example: ]LINK.Create -getFilename=Foo ns /tmp/folder Your function will be called with a nested right argument containing the following elements: Index Description [1] Event name ( 'getFilename' ) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to use (directories end with a slash) [4] Fully qualified APL name of the item [5] Name class of the APL item [6] Old APL name (different from APL name if the write is due to a rename) Note Do not assume a specific length, more elements may be added in the future. Your callback function must return a simple character vector which must be one of: empty: to signify that Link should proceed with the suggested file name. non-empty: to specify the name to be used.","title":"getFilename"},{"location":"API/Link.Create/#codeextensions","text":"Default: 'aplf' 'aplo' 'apln' 'aplc' 'apli' 'dyalog' 'apl' 'mipage' Specify file extensions that are expected to contain source code. Link will only process changes to files with the specified extensions. var is a nested vector of character vectors. From a user command, the syntax is -codeExtensions=var where var holds the expected vector of extensions.","title":"codeExtensions"},{"location":"API/Link.Create/#customextensions","text":"Default: '' \u235d an empty character vector meaning no custom extensions Specifies additional file extensions handled by beforeRead functions. customExtensions is a nested vector of character vectors. From a user command, the syntax is -customExtensions=var where var holds the expected vector. If you have specified a beforeRead handler function, and your code supports the use of custom file extensions to store source data in application-specific formats, you need to set customExtensions so that Link does not ignore changes to these file types. The reason for splitting the list of extensions into two parts ( codeExtensions and customExtensions ) is to avoid your code having to repeat the list of standard extensions, or update this list if it should be extended in the future.","title":"customExtensions"},{"location":"API/Link.Create/#typeextensions","text":"Default: 6 2\u23742 'apla' 3 'aplf' 4 'aplo' 9.1 'apln' 9.4 'aplc' 9.5 'apli' The typeExtensions table specifies the default extension that should be used when creating a new file to contain the source for an item of a given type. typeExtensions is a two-column matrix with numeric name class numbers in the first column and character vectors of corresponding file extensions in the second column. Note that, although you can change the extensions used, Link will add default definitions for any of the types that you do not specify. For example, if you do not include a row for type 9.5, Link will use 'apli' for interfaces. From a user command, the syntax is -typeExtensions=var where var holds the expected array. Note that the forceExtensions switch can be used to correct all extensions on pre-existing files when a link is created. The default corresponds to: Type extension 2 apla 3 aplf 4 aplo 9.1 apln 9.4 aplc 9.5 apli","title":"typeExtensions"},{"location":"API/Link.Create/#fastload","text":"Default: off The fastload flag will reduce the load time by not inspecting the source to detect name clashes. This affects only initial directory loading, but not subsequent editor or file system watcher events. It is worth setting fastLoad for very large projects that don't produce name clashes (that is, two files defining the same APL name). Side effects are (again, only at initial load time, not at subsequent events): good: load will be significantly faster because files won't be inspected to determine their true APL name. bad: clashing names won't be detected: files may silently overwrite each other's APL definition if they define the same APL name. bad: forceFilenames / forceExtensions won't be observed bad: beforeRead may report incorrect name class This option takes effect only when source is dir .","title":"fastLoad"},{"location":"API/Link.Create/#ignoreconfig_1","text":"Default: off Ignores any Link configuration files. See Configuration Files for details.","title":"ignoreconfig"},{"location":"API/Link.Create/#text","text":"Default: aplan Chooses whether plain text arrays are stored using APL Array Notation (APLAN) or as plain text files. text is a simple character vector and must be either 'aplan' or 'plain' . See Array Formats for details.","title":"text"},{"location":"API/Link.Export/","text":"Link.Export ]LINK.Export [ns] <dir> [-overwrite] [-casecode] [-arrays{=name1,name2,...}] [-sysvars] [-ignoreconfig] [-text={aplan|plain}] msg \u2190 {opts} \u2395SE.Link.Export (ns dir) Show User Command information in the session with ]LINK.Export -? This function takes the same arguments as Link.Create but saves the contents of a namespace to directory without creating a Link. If the source is an unscripted namespace, then the destination is interpreted as a directory. If the source is anything else, then the destination is interpreted as a directory (and a correctly named file will be created there), unless it ends with a recognised extension (like .aplf ), in which case it is interpreted as a file name. Arguments ns : unscripted namespace or APL name. If ns is not provided, the default is to use the current namespace. dir: directory or file name Options overwrite : Allow overwriting existing files in the destination directory other options have same effect as in Link.Create Result String describing the exported source and destination, along with possible failures","title":"Link.Export"},{"location":"API/Link.Export/#linkexport","text":"]LINK.Export [ns] <dir> [-overwrite] [-casecode] [-arrays{=name1,name2,...}] [-sysvars] [-ignoreconfig] [-text={aplan|plain}] msg \u2190 {opts} \u2395SE.Link.Export (ns dir) Show User Command information in the session with ]LINK.Export -? This function takes the same arguments as Link.Create but saves the contents of a namespace to directory without creating a Link. If the source is an unscripted namespace, then the destination is interpreted as a directory. If the source is anything else, then the destination is interpreted as a directory (and a correctly named file will be created there), unless it ends with a recognised extension (like .aplf ), in which case it is interpreted as a file name.","title":"Link.Export"},{"location":"API/Link.Export/#arguments","text":"ns : unscripted namespace or APL name. If ns is not provided, the default is to use the current namespace. dir: directory or file name","title":"Arguments"},{"location":"API/Link.Export/#options","text":"overwrite : Allow overwriting existing files in the destination directory other options have same effect as in Link.Create","title":"Options"},{"location":"API/Link.Export/#result","text":"String describing the exported source and destination, along with possible failures","title":"Result"},{"location":"API/Link.Expunge/","text":"Link.Expunge ]LINK.Expunge <item> {available} \u2190 \u2395SE.Link.Expunge items Show User Command information in the session with ]LINK.Expunge -? This function is intended as a replacement for the system function \u2395EX in tools that manage code. It removes an item from the workspace and also deletes the corresponding source file. If you manually )ERASE items, you can subsequently call Expunge to remove the source file. Arguments APL item name(s) Result Simple Boolean vector with one element per name in the right argument. The value of an element of the result is 1 if the corresponding name is now available for use. This does not necessarily mean that the existing value was erased for that name. A value of 0 is returned for an ill-formed name or for a distinguished name in the argument.","title":"Link.Expunge"},{"location":"API/Link.Expunge/#linkexpunge","text":"]LINK.Expunge <item> {available} \u2190 \u2395SE.Link.Expunge items Show User Command information in the session with ]LINK.Expunge -? This function is intended as a replacement for the system function \u2395EX in tools that manage code. It removes an item from the workspace and also deletes the corresponding source file. If you manually )ERASE items, you can subsequently call Expunge to remove the source file.","title":"Link.Expunge"},{"location":"API/Link.Expunge/#arguments","text":"APL item name(s)","title":"Arguments"},{"location":"API/Link.Expunge/#result","text":"Simple Boolean vector with one element per name in the right argument. The value of an element of the result is 1 if the corresponding name is now available for use. This does not necessarily mean that the existing value was erased for that name. A value of 0 is returned for an ill-formed name or for a distinguished name in the argument.","title":"Result"},{"location":"API/Link.Fix/","text":"Link.Fix {fixed} \u2190 {namespace} {name} {oldname} \u2395SE.Link. Fix src This function is intended as a replacement for \u2395FIX or \u2395FX in environments in which some or all namespaces are linked. It will allow you to add or modify an array, function, operator, or scripted namespace, class or interface, without worrying about whether the namespace is linked. The source will be fixed in the target namespace, and the corresponding file will be created/updated if there is an active link which specifies that the namespace is being watched. For arrays, Fix expects the source to be Array Notation (you can use \u2395SE.Dyalog.Array.Serialise to produce it from array values). For other items, it uses the source in the form that would be produced by \u2395NR or \u2395SRC . In all cases the source is a vector of text vectors. Normally, one can use \u2395FIX or \u2395FX inside the target namespace, e.g. myns.\u2395FIX 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}' but since Link.Fix exists only as \u2395SE.Link.Fix then the target namespace must be explicitly specified as in myns \u2395SE.Link.Fix 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}' . The default namespace is the calling namespace. Note: If the item has already been updated or created and you only need to trigger an update of the source file, you can also use Link.Add . Right Argument: source A vector of character vectors representing the source code of the item to be defined Left Argument: {namespace} {name} {oldname} namespace: The namespace (by name or by reference) within which the source shall be fixed. Defaults to '' which means the calling namespace. name: The name of the item being defined. Defaults to '' which means that the name will be defined by the source to be fixed. The name is required only for arrays, because their source doesn't contain their name. oldname: The old name of the fixed item, if this operation is a rename. Defaults to name , which means it is not a rename. Result The name of the item that was defined.","title":"Link.Fix"},{"location":"API/Link.Fix/#linkfix","text":"{fixed} \u2190 {namespace} {name} {oldname} \u2395SE.Link. Fix src This function is intended as a replacement for \u2395FIX or \u2395FX in environments in which some or all namespaces are linked. It will allow you to add or modify an array, function, operator, or scripted namespace, class or interface, without worrying about whether the namespace is linked. The source will be fixed in the target namespace, and the corresponding file will be created/updated if there is an active link which specifies that the namespace is being watched. For arrays, Fix expects the source to be Array Notation (you can use \u2395SE.Dyalog.Array.Serialise to produce it from array values). For other items, it uses the source in the form that would be produced by \u2395NR or \u2395SRC . In all cases the source is a vector of text vectors. Normally, one can use \u2395FIX or \u2395FX inside the target namespace, e.g. myns.\u2395FIX 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}' but since Link.Fix exists only as \u2395SE.Link.Fix then the target namespace must be explicitly specified as in myns \u2395SE.Link.Fix 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}' . The default namespace is the calling namespace. Note: If the item has already been updated or created and you only need to trigger an update of the source file, you can also use Link.Add .","title":"Link.Fix"},{"location":"API/Link.Fix/#right-argument-source","text":"A vector of character vectors representing the source code of the item to be defined","title":"Right Argument: source"},{"location":"API/Link.Fix/#left-argument-namespace-name-oldname","text":"namespace: The namespace (by name or by reference) within which the source shall be fixed. Defaults to '' which means the calling namespace. name: The name of the item being defined. Defaults to '' which means that the name will be defined by the source to be fixed. The name is required only for arrays, because their source doesn't contain their name. oldname: The old name of the fixed item, if this operation is a rename. Defaults to name , which means it is not a rename.","title":"Left Argument: {namespace} {name} {oldname}"},{"location":"API/Link.Fix/#result","text":"The name of the item that was defined.","title":"Result"},{"location":"API/Link.GetFileName/","text":"Link.GetFileName files \u2190 \u2395SE.Link.GetFileName items Returns the fully qualified name of the file containing the source of the given APL item. See also \u2395SE.Link.GetItemName . Arguments A simple vector with an APL item name, or a vector enclosed names. The result will have the same structure as the argument. Result For each APL item name: if item does not exist or does not belong to a linked namespace: empty vector otherwise: file name that the item is linked to","title":"Link.GetFileName"},{"location":"API/Link.GetFileName/#linkgetfilename","text":"files \u2190 \u2395SE.Link.GetFileName items Returns the fully qualified name of the file containing the source of the given APL item. See also \u2395SE.Link.GetItemName .","title":"Link.GetFileName"},{"location":"API/Link.GetFileName/#arguments","text":"A simple vector with an APL item name, or a vector enclosed names. The result will have the same structure as the argument.","title":"Arguments"},{"location":"API/Link.GetFileName/#result","text":"For each APL item name: if item does not exist or does not belong to a linked namespace: empty vector otherwise: file name that the item is linked to","title":"Result"},{"location":"API/Link.GetItemName/","text":"Link.GetItemName items \u2190 \u2395SE.Link.GetItemName files Returns the name of the fully qualified APL item that is linked to a file. See also \u2395SE.Link.GetFileName . Arguments A simple vector containing a file name, or a vector of enclosed names. The result will have the same structure as the argument. Result For each file name: if file does not exist or does not belong to a linked directory: empty vector otherwise : item name that the file is linked to","title":"Link.GetItemName"},{"location":"API/Link.GetItemName/#linkgetitemname","text":"items \u2190 \u2395SE.Link.GetItemName files Returns the name of the fully qualified APL item that is linked to a file. See also \u2395SE.Link.GetFileName .","title":"Link.GetItemName"},{"location":"API/Link.GetItemName/#arguments","text":"A simple vector containing a file name, or a vector of enclosed names. The result will have the same structure as the argument.","title":"Arguments"},{"location":"API/Link.GetItemName/#result","text":"For each file name: if file does not exist or does not belong to a linked directory: empty vector otherwise : item name that the file is linked to","title":"Result"},{"location":"API/Link.Import/","text":"Link.Import ]LINK.Import [ns] <dir> [-overwrite] [-flatten] [-fastload] [-ignoreconfig] msg \u2190 {opts} \u2395SE.Link.Import (ns dir) Show User Command information in the session with ]LINK.Import -? This function takes the same arguments as Link.Create , but loads a directory containing source files into a namespace without creating an active link. If source is a directory, then its contents are imported into the destination namespace. If source is a single file, then the corresponding APL name is created in the destination namespace. Arguments ns: namespace. If ns is not provided, it defaults to the current namespace. dir: directory or file name Options overwrite : Allow overwriting APL names in the destination namespace other options have same effect as in Link.Create Result String describing the imported destination and source, along with possible failures","title":"Link.Import"},{"location":"API/Link.Import/#linkimport","text":"]LINK.Import [ns] <dir> [-overwrite] [-flatten] [-fastload] [-ignoreconfig] msg \u2190 {opts} \u2395SE.Link.Import (ns dir) Show User Command information in the session with ]LINK.Import -? This function takes the same arguments as Link.Create , but loads a directory containing source files into a namespace without creating an active link. If source is a directory, then its contents are imported into the destination namespace. If source is a single file, then the corresponding APL name is created in the destination namespace.","title":"Link.Import"},{"location":"API/Link.Import/#arguments","text":"ns: namespace. If ns is not provided, it defaults to the current namespace. dir: directory or file name","title":"Arguments"},{"location":"API/Link.Import/#options","text":"overwrite : Allow overwriting APL names in the destination namespace other options have same effect as in Link.Create","title":"Options"},{"location":"API/Link.Import/#result","text":"String describing the imported destination and source, along with possible failures","title":"Result"},{"location":"API/Link.LaunchDir/","text":"Link.LaunchDir dir \u2190 \u2395SE.Link.LaunchDir If APL was launched with a LOAD or CONFIGFILE parameter, Link.LaunchDir returns the fully qualified name of the directory in which the file used to start APL is located. If both were specified, the LOAD ed file takes priority. If neither parameter is specified, the current working directory is returned. This function is useful during the startup of applications loaded directly from source, and allows you to locate additional resources that are located relative to the source for the code used to start the application. For examples of usage, see setting up your environment Arguments None Result A character vector containing a fully qualified directory name.","title":"Link.LaunchDir"},{"location":"API/Link.LaunchDir/#linklaunchdir","text":"dir \u2190 \u2395SE.Link.LaunchDir If APL was launched with a LOAD or CONFIGFILE parameter, Link.LaunchDir returns the fully qualified name of the directory in which the file used to start APL is located. If both were specified, the LOAD ed file takes priority. If neither parameter is specified, the current working directory is returned. This function is useful during the startup of applications loaded directly from source, and allows you to locate additional resources that are located relative to the source for the code used to start the application. For examples of usage, see setting up your environment","title":"Link.LaunchDir"},{"location":"API/Link.LaunchDir/#arguments","text":"None","title":"Arguments"},{"location":"API/Link.LaunchDir/#result","text":"A character vector containing a fully qualified directory name.","title":"Result"},{"location":"API/Link.Notify/","text":"Link.Notify {name} \u2190 \u2395SE.Link.Notify args When synchonisation is active, Link will call Notify each time it detects a change to a linked source file. If synchronisation is not enabled, you can use this function to bring an external change into the active workspace, to notify the link system that an external file has changed. If the workspace and directories become un-synchronised, you are probably better off using Link.Resync to get a list of differences, or Link.Refresh to completely re-load the external source. Arguments type of event that happened 'created' : new file 'changed' : update to existing file 'renamed' : a file or subdirectory got a new name 'deleted' : a file or directory was erased path of affected file or directory oldpath is the previous path can be omitted for all but a rename event Result If link updated an APL item, its full name is returned as a string. Otherwise an empty string is returned.","title":"Link.Notify"},{"location":"API/Link.Notify/#linknotify","text":"{name} \u2190 \u2395SE.Link.Notify args When synchonisation is active, Link will call Notify each time it detects a change to a linked source file. If synchronisation is not enabled, you can use this function to bring an external change into the active workspace, to notify the link system that an external file has changed. If the workspace and directories become un-synchronised, you are probably better off using Link.Resync to get a list of differences, or Link.Refresh to completely re-load the external source.","title":"Link.Notify"},{"location":"API/Link.Notify/#arguments","text":"type of event that happened 'created' : new file 'changed' : update to existing file 'renamed' : a file or subdirectory got a new name 'deleted' : a file or directory was erased path of affected file or directory oldpath is the previous path can be omitted for all but a rename event","title":"Arguments"},{"location":"API/Link.Notify/#result","text":"If link updated an APL item, its full name is returned as a string. Otherwise an empty string is returned.","title":"Result"},{"location":"API/Link.Refresh/","text":"Link.Refresh ]LINK.Refresh <ns> [-source={ns|dir|auto}] msg \u2190 {opts} \u2395SE.Link.Refresh ns Show User Command information in the session with ]LINK.Refresh -? Refresh will break and re-create a link by using one one side of the link as source, and bringing the other side into line. Note Refresh has the potential to lose changes: Refresh will overwrite one end of the link without checking for changes. Link.Resync provides better control, allowing you to review the differences before selecting how they should be resolved, and is now recommended in place of Refresh in most scenarios. Refresh is useful when you have decided not to watch one side of a link, but now want to pick up any changes that have happened since the link was created or most recently refreshed. To bring the workspace into line with the source directories, use source=dir . If you have made changes to linked namespaces using other mechanisms than the editor (such as using \u2395FIX , \u2395FX , \u2395NS , \u2395CY or assignment), you can Refresh with source=ns to update the directory. Arguments namespace(s) Options source {ns|dir| auto } Whether to consider the ns or dir as the source for the link. - dir means that items in the namespace will be overwritten by items in files. - ns means that items in files will be overwritten by items in the namespace. - auto re-uses the same source that was determined at Create time. The default is to use the setting that was specified at creation ( auto ). Result String describing the established link, along with possible failures","title":"Link.Refresh"},{"location":"API/Link.Refresh/#linkrefresh","text":"]LINK.Refresh <ns> [-source={ns|dir|auto}] msg \u2190 {opts} \u2395SE.Link.Refresh ns Show User Command information in the session with ]LINK.Refresh -? Refresh will break and re-create a link by using one one side of the link as source, and bringing the other side into line. Note Refresh has the potential to lose changes: Refresh will overwrite one end of the link without checking for changes. Link.Resync provides better control, allowing you to review the differences before selecting how they should be resolved, and is now recommended in place of Refresh in most scenarios. Refresh is useful when you have decided not to watch one side of a link, but now want to pick up any changes that have happened since the link was created or most recently refreshed. To bring the workspace into line with the source directories, use source=dir . If you have made changes to linked namespaces using other mechanisms than the editor (such as using \u2395FIX , \u2395FX , \u2395NS , \u2395CY or assignment), you can Refresh with source=ns to update the directory.","title":"Link.Refresh"},{"location":"API/Link.Refresh/#arguments","text":"namespace(s)","title":"Arguments"},{"location":"API/Link.Refresh/#options","text":"source {ns|dir| auto } Whether to consider the ns or dir as the source for the link. - dir means that items in the namespace will be overwritten by items in files. - ns means that items in files will be overwritten by items in the namespace. - auto re-uses the same source that was determined at Create time. The default is to use the setting that was specified at creation ( auto ).","title":"Options"},{"location":"API/Link.Refresh/#result","text":"String describing the established link, along with possible failures","title":"Result"},{"location":"API/Link.Resync/","text":"Link.Resync ]LINK.Resync <ns> msg \u2190 {opts} \u2395SE.Link.Resync \u236c Show User Command information in the session with ]LINK.Resync -? Link.Resync will re-synchronise the contents of linked namespaces and the corresponding source directories. It is useful when: You know that you have made changes of a type which will not trigger updates, such as function assignments or the )COPY system command You have reason to believe that the file system watcher might have missed some updates You have loaded a workspace that was saved with active links. In this case, all Link functionality will be disabled until you do a Resync to ensure that the workspace content matches the external source. By default, Resync takes no action, but outputs a list of differences found, with a recommendation of whether the the difference should be resolved by updating a file should be created or updated ( \u2192 ), or that a file should be read and the workspace updated ( \u2190 ). For example: ]link.resync 2 updates required: use -proceed option to synchronise Name Direction File Comments #.badapp.Foo \u2192 Item has no corresponding file #.badapp.Goo \u2190 /myapp/Goo.aplf File is dated 08:17 yesterday, WS copy is dated 03 Sep 2021 If you accept the recommendations, you can add the proceed switch, after which the link will be up-to-date and work can proceed normally. ]link.resync -proceed 1 file read, 1 file updated If Link is not able to suggest an action, it will display ? in the direction column, for example if the source file is now older than when it was loaded into the workspace, -proceed will be rejected, you will need to resolve the difference manually. Note Beware: The recommendations are NOT necessarily the correct actions! For example, if an item exists in the workspace but not on file, Resync will recommend creating the file (and vice versa if a file exists but the item is not found in the workspace). But if the file was intentionally removed or renamed in the source, the correct action is actually to delete or rename it in the workspace. Always review the recommendations carefully before -proceed ing. Of course, if you are using a source code management system like Git, you should easily be able to detect and recover from mistakes. Arguments ns: namespace(s) to consider Options proceed Whether to execute the changes suggested by Resync without the proceed option. arrays , sysvars Whether arrays and system variables should be included in the analysis. See Link.Create for details of these options. Result String describing the changes made, if requested.","title":"Link.Resync"},{"location":"API/Link.Resync/#linkresync","text":"]LINK.Resync <ns> msg \u2190 {opts} \u2395SE.Link.Resync \u236c Show User Command information in the session with ]LINK.Resync -? Link.Resync will re-synchronise the contents of linked namespaces and the corresponding source directories. It is useful when: You know that you have made changes of a type which will not trigger updates, such as function assignments or the )COPY system command You have reason to believe that the file system watcher might have missed some updates You have loaded a workspace that was saved with active links. In this case, all Link functionality will be disabled until you do a Resync to ensure that the workspace content matches the external source. By default, Resync takes no action, but outputs a list of differences found, with a recommendation of whether the the difference should be resolved by updating a file should be created or updated ( \u2192 ), or that a file should be read and the workspace updated ( \u2190 ). For example: ]link.resync 2 updates required: use -proceed option to synchronise Name Direction File Comments #.badapp.Foo \u2192 Item has no corresponding file #.badapp.Goo \u2190 /myapp/Goo.aplf File is dated 08:17 yesterday, WS copy is dated 03 Sep 2021 If you accept the recommendations, you can add the proceed switch, after which the link will be up-to-date and work can proceed normally. ]link.resync -proceed 1 file read, 1 file updated If Link is not able to suggest an action, it will display ? in the direction column, for example if the source file is now older than when it was loaded into the workspace, -proceed will be rejected, you will need to resolve the difference manually. Note Beware: The recommendations are NOT necessarily the correct actions! For example, if an item exists in the workspace but not on file, Resync will recommend creating the file (and vice versa if a file exists but the item is not found in the workspace). But if the file was intentionally removed or renamed in the source, the correct action is actually to delete or rename it in the workspace. Always review the recommendations carefully before -proceed ing. Of course, if you are using a source code management system like Git, you should easily be able to detect and recover from mistakes.","title":"Link.Resync"},{"location":"API/Link.Resync/#arguments","text":"ns: namespace(s) to consider","title":"Arguments"},{"location":"API/Link.Resync/#options","text":"proceed Whether to execute the changes suggested by Resync without the proceed option. arrays , sysvars Whether arrays and system variables should be included in the analysis. See Link.Create for details of these options.","title":"Options"},{"location":"API/Link.Resync/#result","text":"String describing the changes made, if requested.","title":"Result"},{"location":"API/Link.Status/","text":"Link.Status ]LINK.Status [<ns>] [-extended] status \u2190 {opts} \u2395SE.Link.Status ns Show User Command information in the session with ]LINK.Status -? This function provides information about existing links. Arguments ns: namespace to look for links in (use '' to list all links) Options extended { 0 |1} Request additional information Result Table of links The first row contains column headers. First three columns are always: namespace reference name of the linked directory or source file number of linked files and directories (excluding root directory) If extended was specified, options settings for each link: case code flatten force extensions force filenames watch paused","title":"Link.Status"},{"location":"API/Link.Status/#linkstatus","text":"]LINK.Status [<ns>] [-extended] status \u2190 {opts} \u2395SE.Link.Status ns Show User Command information in the session with ]LINK.Status -? This function provides information about existing links.","title":"Link.Status"},{"location":"API/Link.Status/#arguments","text":"ns: namespace to look for links in (use '' to list all links)","title":"Arguments"},{"location":"API/Link.Status/#options","text":"extended { 0 |1} Request additional information","title":"Options"},{"location":"API/Link.Status/#result","text":"Table of links The first row contains column headers. First three columns are always: namespace reference name of the linked directory or source file number of linked files and directories (excluding root directory) If extended was specified, options settings for each link: case code flatten force extensions force filenames watch paused","title":"Result"},{"location":"API/Link.Stop/","text":"Link.Stop Syntax ]LINK.Stop <name> [lines] message \u2190 \u2395SE.Link.Stop name [lines] Show User Command information in the session with ]LINK.Stop -? This function allows you to set stops on selected lines of a function or operator. It will also store the setting in the .linkconfig file for the directory, so that the stops will be re-applied the next time the directory is linked, as would be the case if the stops were set using the editor. Arguments name is the name of an existing function or operator. lines is a list of integer line numbers, or \"\u236c\" to clear all stops. Result message is a simple character vector containing the previous settings.","title":"Link.Stop"},{"location":"API/Link.Stop/#linkstop","text":"","title":"Link.Stop"},{"location":"API/Link.Stop/#syntax","text":"]LINK.Stop <name> [lines] message \u2190 \u2395SE.Link.Stop name [lines] Show User Command information in the session with ]LINK.Stop -? This function allows you to set stops on selected lines of a function or operator. It will also store the setting in the .linkconfig file for the directory, so that the stops will be re-applied the next time the directory is linked, as would be the case if the stops were set using the editor.","title":"Syntax"},{"location":"API/Link.Stop/#arguments","text":"name is the name of an existing function or operator. lines is a list of integer line numbers, or \"\u236c\" to clear all stops.","title":"Arguments"},{"location":"API/Link.Stop/#result","text":"message is a simple character vector containing the previous settings.","title":"Result"},{"location":"API/Link.StripCaseCode/","text":"Link.StripCaseCode files \u2190 {opts} \u2395SE.Link.StripCaseCode files If case codes is on (default is off), each file name will have a case code . If you set up a beforeRead hook when creating a Link , Link will allow your prompt your hook take appropriate action before a file is imported. If the filename may have a case code. The StripCaseCode function is provided to remove case coding from any file name. Arguments file name(s) Result file name(s) without case code","title":"Link.StripCaseCode"},{"location":"API/Link.StripCaseCode/#linkstripcasecode","text":"files \u2190 {opts} \u2395SE.Link.StripCaseCode files If case codes is on (default is off), each file name will have a case code . If you set up a beforeRead hook when creating a Link , Link will allow your prompt your hook take appropriate action before a file is imported. If the filename may have a case code. The StripCaseCode function is provided to remove case coding from any file name.","title":"Link.StripCaseCode"},{"location":"API/Link.StripCaseCode/#arguments","text":"file name(s)","title":"Arguments"},{"location":"API/Link.StripCaseCode/#result","text":"file name(s) without case code","title":"Result"},{"location":"API/Link.Trace/","text":"Link.Trace Syntax ]LINK.Trace <name> [lines] message \u2190 \u2395SE.Link.Trace name [lines] Show User Command information in the session with ]LINK.Trace -? This function allows you to set stops on selected lines of a function or operator. It will also store the setting in the .linkconfig file for the directory, so that the trace settings will be re-applied the next time the directory is linked, as would be the case if they were set using the editor. Arguments name is the name of an existing function or operator. lines is a list of integer line numbers, or \"\u236c\" to clear all settings. Result message is a simple character vector containing the previous settings.","title":"Link.Trace"},{"location":"API/Link.Trace/#linktrace","text":"","title":"Link.Trace"},{"location":"API/Link.Trace/#syntax","text":"]LINK.Trace <name> [lines] message \u2190 \u2395SE.Link.Trace name [lines] Show User Command information in the session with ]LINK.Trace -? This function allows you to set stops on selected lines of a function or operator. It will also store the setting in the .linkconfig file for the directory, so that the trace settings will be re-applied the next time the directory is linked, as would be the case if they were set using the editor.","title":"Syntax"},{"location":"API/Link.Trace/#arguments","text":"name is the name of an existing function or operator. lines is a list of integer line numbers, or \"\u236c\" to clear all settings.","title":"Arguments"},{"location":"API/Link.Trace/#result","text":"message is a simple character vector containing the previous settings.","title":"Result"},{"location":"API/Link.TypeExtension/","text":"Link.TypeExtension ext \u2190 opts \u2395SE.Link.TypeExtension nc This function is used internally by Link, but is also available for use when implementing extensions to Link using exits like beforeRead and beforeWrite . Right Argument nameclass of item Left argument link options namespace used as left argument of Link.Create Result character vector of the extension (without leading '.' )\\ Note that extension will be ( ,'/' ) for unscripted namespaces (name class \u00af9 ) because they map to directories","title":"Link.TypeExtension"},{"location":"API/Link.TypeExtension/#linktypeextension","text":"ext \u2190 opts \u2395SE.Link.TypeExtension nc This function is used internally by Link, but is also available for use when implementing extensions to Link using exits like beforeRead and beforeWrite .","title":"Link.TypeExtension"},{"location":"API/Link.TypeExtension/#right-argument","text":"nameclass of item","title":"Right Argument"},{"location":"API/Link.TypeExtension/#left-argument","text":"link options namespace used as left argument of Link.Create","title":"Left argument"},{"location":"API/Link.TypeExtension/#result","text":"character vector of the extension (without leading '.' )\\ Note that extension will be ( ,'/' ) for unscripted namespaces (name class \u00af9 ) because they map to directories","title":"Result"},{"location":"API/Link.Version/","text":"Link.Version version \u2190 \u2395SE.Link.Version This niladic function returns the current Link semantic version number as a string in the format 'X.Y.Z' , where X Y and Z are non-negative integers. Development or experimental versions will have a trailing hyphen and string such as 'X.Y.Z-alpha3' .","title":"Link.Version"},{"location":"API/Link.Version/#linkversion","text":"version \u2190 \u2395SE.Link.Version This niladic function returns the current Link semantic version number as a string in the format 'X.Y.Z' , where X Y and Z are non-negative integers. Development or experimental versions will have a trailing hyphen and string such as 'X.Y.Z-alpha3' .","title":"Link.Version"},{"location":"Discussion/History/","text":"History of source files as text in Dyalog Link is another step in the journey from binary workspaces to APL source in text files. Workspaces Historically, APL systems have used saved workspaces as the way to store the current state of the interpreter in a binary file which contains a collection of code and data. In many ways, a workspace is similar to a workbook saved by a spreadsheet application; a very convenient package that contains everything the application needs to run. Saving the workspace at the end of a run preserves updated data, as well as any code changes that might have been made. Component Files and SQL Databases Workspaces are very convenient, but the binary format makes them awkward if you want to compare, or otherwise manage, different versions of the source code - or the data, for that matter. Users preferred to store their data in component files or other storage mechanisms. As teams started writing larger systems, many development teams also created their own source code management systems ( SCMs ), typically storing multiple versions of code in component files or SQL tables. These SCMs served large developer teams well for several decades. However, none of them became tools that were shared by the APL community, and they all suffered from the fundamental problem of using binary formats. SALT - the Simple APL Library Toolkit In 2006, Dyalog APL Version 11.0 introduced Classes and the ability to represent Namespaces as text \"scripts\". With that release, Dyalog APL included a tool known as SALT , which supported the use of Unicode text files as backing for the source of not only classes and namespaces, but functions, operators and variables as well. At the same time, a component named SPICE added user commands to Dyalog APL, using text source files which implemented a specific API, based on SALT's file handling. SALT is Link's direct predecessor, and has many of the same features as Link: The ability to load entire directory structures into the workspace as namespaces A tool called \"Snap\", which would write all or selected parts of a workspace to corresponding source files. A hook in the APL system editor, which would update source files as soon as code was edited, without requiring a separate save operation. Startup processing of files with a .dyapp extension, to allow launching applications from text files without requiring a \"boot workspace\". Link 2.0 After SALT had grown organically for more than a decade, it was decided that this functionality should be re-implemented in a new system: the Link project began. The first version of Link that was released to the general public was 2.0. The main differences between Link and SALT are: Link delegates the task of maintaining information about external source files to the APL interpreter, rather than using a trailing comment in functions and operators or \"hidden\" namespaces for classes and namespaces to track this information. New interpreter functionality based on 2 \u2395FIX makes it possible for the interpreter to preserve source code exactly as typed, when an external source file is used. A file system watcher added support for using external editors and immediately replicating the effect of SCM system actions, such as a git pull or revert operation, inside the active workspace. Rather than using the extension .dyalog for all source, Link uses different extensions for different types of source, such as .aplf for functions, .apln for namespaces, and .apla for arrays. Use of a model of the proposed Literal Array Notation to represent arrays, rather than the notation used by SALT. We hope to add support for the array notation to the Dyalog APL interpreter in a future release. Link has no source code management features; the expectation is that users who require SCM will combine Link with an external SCM such as Git or SVN SALT included a simple mechanism for storing and comparing multiple versions of the source for an object by injecting digits into the file name. Link 3.0 (Dyalog version 18.2, 2022) Link 3.0 is the first major revision of Link. It added: Support for saving workspaces containing links and resuming work after a break. Support for names which differ only in case (for example, FOO vs Foo ) in case-insensitive file systems, by adding \"case coding\" information to the file name. The Link.LaunchDir API function, makes it straightforward to determine the folder that APL was launched on, simplifying the task of launching the interpreter using a configuration file or single APL source file. Dyalog version 18.2, released at the same time as Link 3.0, supports identifying a directory with the LOAD= parameter - as an alternative to a workspace, APL source file, or a configuration file. When LOAD identifies a directory, a link will be created on startup (and the function Run invoked, if it exists). A more complete description of Link 3.0 and the differences between Link 2.0 and 3.0 can be found in the Link 3.0 documentation . Link 4.0 (Dyalog version 19.0, 2024) Link 4.0 was the companion release to Dyalog version 19.0 in 2024. The most important new features are: Configuration files to store options for a user or a source code folder The ability to store multi-line character data in plain text files Support for linking a single source file defining a namespace or class More details regarding the new features of Link 4.0 can be found in the Release Notes . Link 4.0 is upwards compatible with Link 3.0, and can also be used with Dyalog version 18.2.","title":"History of source files as text in Dyalog"},{"location":"Discussion/History/#history-of-source-files-as-text-in-dyalog","text":"Link is another step in the journey from binary workspaces to APL source in text files.","title":"History of source files as text in Dyalog"},{"location":"Discussion/History/#workspaces","text":"Historically, APL systems have used saved workspaces as the way to store the current state of the interpreter in a binary file which contains a collection of code and data. In many ways, a workspace is similar to a workbook saved by a spreadsheet application; a very convenient package that contains everything the application needs to run. Saving the workspace at the end of a run preserves updated data, as well as any code changes that might have been made.","title":"Workspaces"},{"location":"Discussion/History/#component-files-and-sql-databases","text":"Workspaces are very convenient, but the binary format makes them awkward if you want to compare, or otherwise manage, different versions of the source code - or the data, for that matter. Users preferred to store their data in component files or other storage mechanisms. As teams started writing larger systems, many development teams also created their own source code management systems ( SCMs ), typically storing multiple versions of code in component files or SQL tables. These SCMs served large developer teams well for several decades. However, none of them became tools that were shared by the APL community, and they all suffered from the fundamental problem of using binary formats.","title":"Component Files and SQL Databases"},{"location":"Discussion/History/#salt-the-simple-apl-library-toolkit","text":"In 2006, Dyalog APL Version 11.0 introduced Classes and the ability to represent Namespaces as text \"scripts\". With that release, Dyalog APL included a tool known as SALT , which supported the use of Unicode text files as backing for the source of not only classes and namespaces, but functions, operators and variables as well. At the same time, a component named SPICE added user commands to Dyalog APL, using text source files which implemented a specific API, based on SALT's file handling. SALT is Link's direct predecessor, and has many of the same features as Link: The ability to load entire directory structures into the workspace as namespaces A tool called \"Snap\", which would write all or selected parts of a workspace to corresponding source files. A hook in the APL system editor, which would update source files as soon as code was edited, without requiring a separate save operation. Startup processing of files with a .dyapp extension, to allow launching applications from text files without requiring a \"boot workspace\".","title":"SALT - the Simple APL Library Toolkit"},{"location":"Discussion/History/#link-20","text":"After SALT had grown organically for more than a decade, it was decided that this functionality should be re-implemented in a new system: the Link project began. The first version of Link that was released to the general public was 2.0. The main differences between Link and SALT are: Link delegates the task of maintaining information about external source files to the APL interpreter, rather than using a trailing comment in functions and operators or \"hidden\" namespaces for classes and namespaces to track this information. New interpreter functionality based on 2 \u2395FIX makes it possible for the interpreter to preserve source code exactly as typed, when an external source file is used. A file system watcher added support for using external editors and immediately replicating the effect of SCM system actions, such as a git pull or revert operation, inside the active workspace. Rather than using the extension .dyalog for all source, Link uses different extensions for different types of source, such as .aplf for functions, .apln for namespaces, and .apla for arrays. Use of a model of the proposed Literal Array Notation to represent arrays, rather than the notation used by SALT. We hope to add support for the array notation to the Dyalog APL interpreter in a future release. Link has no source code management features; the expectation is that users who require SCM will combine Link with an external SCM such as Git or SVN SALT included a simple mechanism for storing and comparing multiple versions of the source for an object by injecting digits into the file name.","title":"Link 2.0"},{"location":"Discussion/History/#link-30-dyalog-version-182-2022","text":"Link 3.0 is the first major revision of Link. It added: Support for saving workspaces containing links and resuming work after a break. Support for names which differ only in case (for example, FOO vs Foo ) in case-insensitive file systems, by adding \"case coding\" information to the file name. The Link.LaunchDir API function, makes it straightforward to determine the folder that APL was launched on, simplifying the task of launching the interpreter using a configuration file or single APL source file. Dyalog version 18.2, released at the same time as Link 3.0, supports identifying a directory with the LOAD= parameter - as an alternative to a workspace, APL source file, or a configuration file. When LOAD identifies a directory, a link will be created on startup (and the function Run invoked, if it exists). A more complete description of Link 3.0 and the differences between Link 2.0 and 3.0 can be found in the Link 3.0 documentation .","title":"Link 3.0 (Dyalog version 18.2, 2022)"},{"location":"Discussion/History/#link-40-dyalog-version-190-2024","text":"Link 4.0 was the companion release to Dyalog version 19.0 in 2024. The most important new features are: Configuration files to store options for a user or a source code folder The ability to store multi-line character data in plain text files Support for linking a single source file defining a namespace or class More details regarding the new features of Link 4.0 can be found in the Release Notes . Link 4.0 is upwards compatible with Link 3.0, and can also be used with Dyalog version 18.2.","title":"Link 4.0 (Dyalog version 19.0, 2024)"},{"location":"Discussion/TechDetails/","text":"Technical Details and Limitations Link enables the use of text files as application source by mapping workspace content to directories and files. There are some types of objects that cannot be supported, and a few other limitations to be aware of. Supported Objects In the following, for want of a better word, the term object will be used to refer to any kind of named entity that can exist in an APL workspace - not limited to classes or instances. Supported: Link supports objects of name class 2.1 (array), 3.1 (traditional function), 3.2 (d-function), 4.1 (traditional operator), 4.2 (d-operator), 9.1 (namespace), 9.4 (class) and 9.5 (interface). Unscripted Namespaces: Namespaces created with \u2395NS or )NS have no source code of their own and are mapped to directories. Classes and Scripted Namespaces: Classes and so-called scripted namespaces created using the editor or \u2395FIX , have textual source and are treated the same way as functions and other \"code objects\". Support for scripted namespaces as endpoints for a Link was introduced in Link 4.0. Before 4.0, scripted namespaces were allowed only as objects within a an unscripted linked namespace. Note that unnamed namespaces are NOT supported, either as endpoints of a Link or indeed within a linked namespace: Changes to - or within - unnamed namespaces will be ignored by Link . This is discussed in more detail in the next section. Variables are ignored by default, because most of them are not part of the source code of an application. However, they may be explicitly saved to file with Link.Add , or with the -arrays modifier of Link.Create and Link.Export . Functions and Operators: Link is not able to represent names which refer to primitive or derived functions or operators, or trains. You will need to define such objects in the source of another function, or a scripted namespace. For example, the derived function Pairs\u2190\u22a2\u233a(\u236a2 2) cannot be represented directly. However, inclusion of the following tradfn will have the desired effect: \u2207 F\u2190Pairs F\u2190\u22a2\u233a(\u236a2 2) \u2207 Unsupported: In addition to unnamed namespaces, Link has no support for name classes 2.2 (field), 2.3 (property), 2.6 (external/shared variable), 3.3 (primitive or derived function or train), 4.3 (primitive or derived operator), 3.6 (external function) 9.2 (instance), 9.6 (external class) and 9.7 (external interface). These can be listed with ]names 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7 and listed for the namespace myns with ]names myns 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7 . Other Limitations Namespaces must be named. To be precise, it must be true that ns\u2261(\u2395NS\u236c)\u234e\u2355ns . Scripted namespaces must not be anonymous. When creating an unscripted namespace, we recommend using \u2395NS dyadically to name the created namespace (for example 'myproject' \u2395NS \u236c rather than myproject\u2190\u2395NS \u236c ). This allows retrieving namespace reference from its display form (for example #.myproject rather than #.[namespace] ). Changes to - or within - unnamed namespaces will be ignored. There must be exactly one file in the directory per named item to be created in the workspace. In particular, you must not have more than one file defining the same object: this will be reported as an error on Link.Create or Link.Import . In other words, Link does not support source files that define multiple names, even though 2\u2218\u2395FIX does support this. In a case-insensitive file system, Links created with default options cannot contain names which differ only in case, because the source files would have indistinguishable names. The caseCode option can be used to get Link to generate file names which encode case information - see Link.Create for more information. Link does not support namespace-tagged functions and operators (e.g. foo\u2190namespace.{function} ). Changes made using \u2190 , \u2395NS , \u2395FX , \u2395FIX , \u2395CY , )NS and )COPY are not currently detected. For Link to be aware of the change, a call must be made to Link.Fix . Similarly, deletions with \u2395EX or )ERASE must be replaced by a call to Link.Expunge . In Dyalog versions 18.2 or earlier, changes made using the line or \"del\" editor are not detected. The detection of external changes to files and directories is currently only supported if a supported flavour of .NET is available to the interpreter. Note that the built-in APL editor will detect changes to source files on all platforms, when it opens an editor window. Source code must not have embedded newlines within character constants. Although \u2395FX does allow this, Link will error if this is attempted. This restriction comes because newline characters would be interpreted as a new line when saved as text file. When newline characters are needed in source code, they should be implemented by a call to \u2395UCS e.g. newline\u2190\u2395UCS 13 10 \u235d carriage-return + line-feed Note If you are still using the pre-Unicode version of Dyalog known as \"Classic\": Link will work, but names which contain characters other than a-z, A-Z, 0-9 and _ will cause Link to create strange file names. For example ]add \u2395IO will cause the creation of a file named \u0152IO.apla . Depending on the names of your objects, this may make it difficult to share source files between Classic and Unicode interpreters. How does Link work? Some people need to know what is happening under the covers before they can relax and move on. If you are not one of those people, do not waste any further time on this section. If you do read it, understand that things may change under the covers without notice, and we will not allow a requirement to keep this document up-to-date to delay work on the code. It is reasonably accurate as of February 2024, at the end of the Link 4.0 development cycle. Terminology: In the following, the term object is used very loosely to refer to functions, operators, namespaces, classes and arrays. What Exactly is a Link? A link connects a namespace in the active workspace (which can be the root namespace # ) to a directory in the file system. When a link is created: An entry is created in the table which is stored in the workspace using an undocumented I-Beam, recording the endpoints and all options associated with the Link. Link.Status can be used to report this information. Earlier versions used \u2395SE.Link.Links , but versions 3.0 and later only store information on links with an endpoint in \u2395SE in that variable. Depending on which end of the link is specified as the source, APL source files are created from workspace definitions, or objects are loaded into the workspace from such files. These processes are described in more detail in the following sections. If .NET is available, a .NET File System Watcher is created to watch the directory for changes so that those changes can immediately be replicated in the workspace (unless an option is set to prevent this). Creating APL Source Files and Directories Link writes textual representations of APL objects to UTF-8 text files (but can load source files created using any Unicode encoding). Most of the time, it uses the system function \u2395SRC to extract the source form writing it to file using \u2395NPUT . There are two exceptions to this: So-called \"unscripted\" namespaces, which contain other objects but do not themselves have a textual source, are represented as sub-directories in the file system (which may contain source files for the objects within the namespace). Arrays are converted to source form using the function \u2395SE.Dyalog.Array.Serialise . It is expected that the APL language engine will, in the future, support the \"literal array notation\". Loading APL Objects from Source With the exception of variables stored in .apla files, Link loads code into the workspace using 2 \u2395FIX . Arrays, stored in .apla files, are either processed by \u2395SE.Dyalog.Array.Deserialise or, if in plain text format (in which case they have a \"sub-extension\", for example .mat.apla ), by Link itself. When you are watching both sides of a link, Link delegates the work of tracking the links to the interpreter. In this case, editing objects will cause the editor itself (not Link) to update the source file. You can inspect the links which are maintained by the interpreter using a family of I-Beams numbered 517x. When a new function, operator, namespace or class is created, a hook in the editor calls Link code which generates a new file and sets up the link. If .NET is available, Link uses a File System Watcher to monitor linked directories and immediately react to file creation, modification or deletion. The Source of Link itself Link consists of a set of API functions which are loaded into the namespace \u2395SE.Link , when APL starts, from $DYALOG/StartupSession/Link . The user command file $DYALOG/SALT/SPICE/Link.dyalog provides access to the interactive user command covers that exist for most of the API functions. Link 4.0 is pre-installed with Dyalog version 19.0 or later. To use version 4.0 with Dyalog 18.2, see the installation instructions . The Crawler In a future version of Link, an optional and configurable crawler will be able to run in the background and occasionally compare linked namespaces and directories, using the same logic as Link.Resync , and deal with anything that might have been missed by the automatic mechanisms. This will be especially useful if: The File System Watcher is not available on your platform You add functions or operators to the active workspace without using the editor, for example using )COPY or dfn assignment. The section on supported objects provides much more information about the type of APL objects that are supported by Link. Breaking Links If Link.Break is used to explicitly break an existing Link the namespace reverts to being a completely \"normal\" namespace in the workspace. If file system watcher was active, it is disabled. Any information that the interpreter was keeping about connections to files is removed using 5178\u2336 . None of the definitions in the namespace are modified by the process of breaking a link. If you delete a linked namespace using )ERASE or \u2395EX , Link may not immediately detect that this has happened. However, if you call Link.Status , or make a change to a watched file that causes the file system watcher to attempt to update the namespace, Link will discover that something is amiss, issue a warning, and delete the link. If you completely destroy the active workspace using )LOAD or )CLEAR , all links with an endpoint in the workspace will be deleted - but links to \u2395SE will survive. The Future To summarise, the Link road map currently includes the following goals: Adding the crawler , which will automatically run Link.Resync in the background, in order to detect and help eliminate differences between the contents of linked namespaces and the corresponding directories. It may replace the File System Watcher in environments where it is not available. Replacing the use of SALT in Dyalog's tools, including a new implementation of user commands and other mechanisms for loading source code into the interpreter based on Link instead. Over time, it is a strategic goal for Dyalog to move more of the work done by Link into the APL interpreter, such as: Serialisation and deserialisation of arrays, using the literal array notation File system watching or other mechanisms for detecting changes to source at both ends of a link","title":"Technical Details and Limitations"},{"location":"Discussion/TechDetails/#technical-details-and-limitations","text":"Link enables the use of text files as application source by mapping workspace content to directories and files. There are some types of objects that cannot be supported, and a few other limitations to be aware of.","title":"Technical Details and Limitations"},{"location":"Discussion/TechDetails/#supported-objects","text":"In the following, for want of a better word, the term object will be used to refer to any kind of named entity that can exist in an APL workspace - not limited to classes or instances. Supported: Link supports objects of name class 2.1 (array), 3.1 (traditional function), 3.2 (d-function), 4.1 (traditional operator), 4.2 (d-operator), 9.1 (namespace), 9.4 (class) and 9.5 (interface). Unscripted Namespaces: Namespaces created with \u2395NS or )NS have no source code of their own and are mapped to directories. Classes and Scripted Namespaces: Classes and so-called scripted namespaces created using the editor or \u2395FIX , have textual source and are treated the same way as functions and other \"code objects\". Support for scripted namespaces as endpoints for a Link was introduced in Link 4.0. Before 4.0, scripted namespaces were allowed only as objects within a an unscripted linked namespace. Note that unnamed namespaces are NOT supported, either as endpoints of a Link or indeed within a linked namespace: Changes to - or within - unnamed namespaces will be ignored by Link . This is discussed in more detail in the next section. Variables are ignored by default, because most of them are not part of the source code of an application. However, they may be explicitly saved to file with Link.Add , or with the -arrays modifier of Link.Create and Link.Export . Functions and Operators: Link is not able to represent names which refer to primitive or derived functions or operators, or trains. You will need to define such objects in the source of another function, or a scripted namespace. For example, the derived function Pairs\u2190\u22a2\u233a(\u236a2 2) cannot be represented directly. However, inclusion of the following tradfn will have the desired effect: \u2207 F\u2190Pairs F\u2190\u22a2\u233a(\u236a2 2) \u2207 Unsupported: In addition to unnamed namespaces, Link has no support for name classes 2.2 (field), 2.3 (property), 2.6 (external/shared variable), 3.3 (primitive or derived function or train), 4.3 (primitive or derived operator), 3.6 (external function) 9.2 (instance), 9.6 (external class) and 9.7 (external interface). These can be listed with ]names 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7 and listed for the namespace myns with ]names myns 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7 .","title":"Supported Objects"},{"location":"Discussion/TechDetails/#other-limitations","text":"Namespaces must be named. To be precise, it must be true that ns\u2261(\u2395NS\u236c)\u234e\u2355ns . Scripted namespaces must not be anonymous. When creating an unscripted namespace, we recommend using \u2395NS dyadically to name the created namespace (for example 'myproject' \u2395NS \u236c rather than myproject\u2190\u2395NS \u236c ). This allows retrieving namespace reference from its display form (for example #.myproject rather than #.[namespace] ). Changes to - or within - unnamed namespaces will be ignored. There must be exactly one file in the directory per named item to be created in the workspace. In particular, you must not have more than one file defining the same object: this will be reported as an error on Link.Create or Link.Import . In other words, Link does not support source files that define multiple names, even though 2\u2218\u2395FIX does support this. In a case-insensitive file system, Links created with default options cannot contain names which differ only in case, because the source files would have indistinguishable names. The caseCode option can be used to get Link to generate file names which encode case information - see Link.Create for more information. Link does not support namespace-tagged functions and operators (e.g. foo\u2190namespace.{function} ). Changes made using \u2190 , \u2395NS , \u2395FX , \u2395FIX , \u2395CY , )NS and )COPY are not currently detected. For Link to be aware of the change, a call must be made to Link.Fix . Similarly, deletions with \u2395EX or )ERASE must be replaced by a call to Link.Expunge . In Dyalog versions 18.2 or earlier, changes made using the line or \"del\" editor are not detected. The detection of external changes to files and directories is currently only supported if a supported flavour of .NET is available to the interpreter. Note that the built-in APL editor will detect changes to source files on all platforms, when it opens an editor window. Source code must not have embedded newlines within character constants. Although \u2395FX does allow this, Link will error if this is attempted. This restriction comes because newline characters would be interpreted as a new line when saved as text file. When newline characters are needed in source code, they should be implemented by a call to \u2395UCS e.g. newline\u2190\u2395UCS 13 10 \u235d carriage-return + line-feed Note If you are still using the pre-Unicode version of Dyalog known as \"Classic\": Link will work, but names which contain characters other than a-z, A-Z, 0-9 and _ will cause Link to create strange file names. For example ]add \u2395IO will cause the creation of a file named \u0152IO.apla . Depending on the names of your objects, this may make it difficult to share source files between Classic and Unicode interpreters.","title":"Other Limitations"},{"location":"Discussion/TechDetails/#how-does-link-work","text":"Some people need to know what is happening under the covers before they can relax and move on. If you are not one of those people, do not waste any further time on this section. If you do read it, understand that things may change under the covers without notice, and we will not allow a requirement to keep this document up-to-date to delay work on the code. It is reasonably accurate as of February 2024, at the end of the Link 4.0 development cycle. Terminology: In the following, the term object is used very loosely to refer to functions, operators, namespaces, classes and arrays.","title":"How does Link work?"},{"location":"Discussion/TechDetails/#what-exactly-is-a-link","text":"A link connects a namespace in the active workspace (which can be the root namespace # ) to a directory in the file system. When a link is created: An entry is created in the table which is stored in the workspace using an undocumented I-Beam, recording the endpoints and all options associated with the Link. Link.Status can be used to report this information. Earlier versions used \u2395SE.Link.Links , but versions 3.0 and later only store information on links with an endpoint in \u2395SE in that variable. Depending on which end of the link is specified as the source, APL source files are created from workspace definitions, or objects are loaded into the workspace from such files. These processes are described in more detail in the following sections. If .NET is available, a .NET File System Watcher is created to watch the directory for changes so that those changes can immediately be replicated in the workspace (unless an option is set to prevent this).","title":"What Exactly is a Link?"},{"location":"Discussion/TechDetails/#creating-apl-source-files-and-directories","text":"Link writes textual representations of APL objects to UTF-8 text files (but can load source files created using any Unicode encoding). Most of the time, it uses the system function \u2395SRC to extract the source form writing it to file using \u2395NPUT . There are two exceptions to this: So-called \"unscripted\" namespaces, which contain other objects but do not themselves have a textual source, are represented as sub-directories in the file system (which may contain source files for the objects within the namespace). Arrays are converted to source form using the function \u2395SE.Dyalog.Array.Serialise . It is expected that the APL language engine will, in the future, support the \"literal array notation\".","title":"Creating APL Source Files and Directories"},{"location":"Discussion/TechDetails/#loading-apl-objects-from-source","text":"With the exception of variables stored in .apla files, Link loads code into the workspace using 2 \u2395FIX . Arrays, stored in .apla files, are either processed by \u2395SE.Dyalog.Array.Deserialise or, if in plain text format (in which case they have a \"sub-extension\", for example .mat.apla ), by Link itself. When you are watching both sides of a link, Link delegates the work of tracking the links to the interpreter. In this case, editing objects will cause the editor itself (not Link) to update the source file. You can inspect the links which are maintained by the interpreter using a family of I-Beams numbered 517x. When a new function, operator, namespace or class is created, a hook in the editor calls Link code which generates a new file and sets up the link. If .NET is available, Link uses a File System Watcher to monitor linked directories and immediately react to file creation, modification or deletion.","title":"Loading APL Objects from Source"},{"location":"Discussion/TechDetails/#the-source-of-link-itself","text":"Link consists of a set of API functions which are loaded into the namespace \u2395SE.Link , when APL starts, from $DYALOG/StartupSession/Link . The user command file $DYALOG/SALT/SPICE/Link.dyalog provides access to the interactive user command covers that exist for most of the API functions. Link 4.0 is pre-installed with Dyalog version 19.0 or later. To use version 4.0 with Dyalog 18.2, see the installation instructions .","title":"The Source of Link itself"},{"location":"Discussion/TechDetails/#the-crawler","text":"In a future version of Link, an optional and configurable crawler will be able to run in the background and occasionally compare linked namespaces and directories, using the same logic as Link.Resync , and deal with anything that might have been missed by the automatic mechanisms. This will be especially useful if: The File System Watcher is not available on your platform You add functions or operators to the active workspace without using the editor, for example using )COPY or dfn assignment. The section on supported objects provides much more information about the type of APL objects that are supported by Link.","title":"The Crawler"},{"location":"Discussion/TechDetails/#breaking-links","text":"If Link.Break is used to explicitly break an existing Link the namespace reverts to being a completely \"normal\" namespace in the workspace. If file system watcher was active, it is disabled. Any information that the interpreter was keeping about connections to files is removed using 5178\u2336 . None of the definitions in the namespace are modified by the process of breaking a link. If you delete a linked namespace using )ERASE or \u2395EX , Link may not immediately detect that this has happened. However, if you call Link.Status , or make a change to a watched file that causes the file system watcher to attempt to update the namespace, Link will discover that something is amiss, issue a warning, and delete the link. If you completely destroy the active workspace using )LOAD or )CLEAR , all links with an endpoint in the workspace will be deleted - but links to \u2395SE will survive.","title":"Breaking Links"},{"location":"Discussion/TechDetails/#the-future","text":"To summarise, the Link road map currently includes the following goals: Adding the crawler , which will automatically run Link.Resync in the background, in order to detect and help eliminate differences between the contents of linked namespaces and the corresponding directories. It may replace the File System Watcher in environments where it is not available. Replacing the use of SALT in Dyalog's tools, including a new implementation of user commands and other mechanisms for loading source code into the interpreter based on Link instead. Over time, it is a strategic goal for Dyalog to move more of the work done by Link into the APL interpreter, such as: Serialisation and deserialisation of arrays, using the literal array notation File system watching or other mechanisms for detecting changes to source at both ends of a link","title":"The Future"},{"location":"Discussion/Workspaces/","text":"Link versus Workspaces As the versus in the heading is intended to imply, the main purpose of Link is to replace many uses of workspaces. Link is intended to make it possible for APL users to move away from the use of workspaces as a mechanism for storing APL source code. Are Workspaces Dead Now? No: Workspaces still have many uses, even if they are falling out of favour as mechanism for source code management: Distribution: For large applications, it will be inconvenient or undesirable to ship large collections of source files that are loaded at startup. The use of workspaces as a mechanism for the distribution of packaged collections of code and data is expected to continue. Crash Analysis: When an application fails, it is often useful to save the workspace, complete with execution stack, code and data, for subsequent analysis and sometimes resumption of execution. Dyalog will continue to support this, although we may gradually impose some restrictions, for example requiring the same version and variant of the interpreter in order to resume execution of a saved workspace. Pausing work: In many ways, this is similar to crash analysis: sometimes you need to shut down your machine in the middle of things and resume later, but you don't want to be forced to start from scratch because you have created an interesting scenario with data in the workspace. Saving a workspace allows you to do this. With the exception of the scenarios mentioned above, Link is intended to make it unnecessary to save workspaces. All source code changes that you make while editing or tracing your code should immediately end up in text files and be managed using an SCM. The normal workflow is to start each APL session by loading the code into the workspace from source directories. You might want to save a \"stub\" workspace that contains a very small amount of code that loads everything else from text source, but from version 18.0 of Dyalog APL you can now easily set that up using text files as well , rendering workspaces obsolete as part of your normal development workflow. Saving workspaces containing Links If you )SAVE a workspace which has active links in it, this creates a potential conflict between the source code embedded in the workspace and any changes that may have been made to external source since the workspace was saved. If you )LOAD a saved workspace, Link will issue a warning along the lines of: IMPORTANT: 1 namespace linked in this workspace: #.myapp IMPORTANT: Link.Resync is required Except for a few reporting tools like Link.Status , link user commands and API functions will be disabled, until you run Link.Resync , which will compare the contents of the workspace and the source directories, list the differences and propose actions to take in order to bring the contents of the workspace in line with the source folders. Note Beware: If you continue working without doing a Resync, strange things may happen: Link user commands and API functions will refuse to perform any actions, but names defined in the linked namespace contain references to external source files that the interpreter and editor will still honour. Using the built-in editor will read the external source file at the start of an editing session, and any changes made will be written to file, even though Link itself remains disabled. In other words, you should NOT continue working without a Resync, unless you have a very good reason to do so and understand exactly what might happen. Distribution If you want to distribute a workspace created using Link to import code, note that if the workspace is loaded on a machine where the recorded source file names are not valid, this will lead to confusion. Application workspaces should always be built using Link.Import . Alternatively, use Link.Break to remove the links before you )SAVE the workspace. Note If you automate a build process using Link.Create rather than Link.Import, immediately followed by a \u2395SAVE , there is a significant chance that a File System Watcher callback will be running in a separate thread, which will cause the \u2395SAVE to fail. See the discussion about setting up your environment for more tips on creating development and runtime environments.","title":"Workspaces"},{"location":"Discussion/Workspaces/#link-versus-workspaces","text":"As the versus in the heading is intended to imply, the main purpose of Link is to replace many uses of workspaces. Link is intended to make it possible for APL users to move away from the use of workspaces as a mechanism for storing APL source code.","title":"Link versus Workspaces"},{"location":"Discussion/Workspaces/#are-workspaces-dead-now","text":"No: Workspaces still have many uses, even if they are falling out of favour as mechanism for source code management: Distribution: For large applications, it will be inconvenient or undesirable to ship large collections of source files that are loaded at startup. The use of workspaces as a mechanism for the distribution of packaged collections of code and data is expected to continue. Crash Analysis: When an application fails, it is often useful to save the workspace, complete with execution stack, code and data, for subsequent analysis and sometimes resumption of execution. Dyalog will continue to support this, although we may gradually impose some restrictions, for example requiring the same version and variant of the interpreter in order to resume execution of a saved workspace. Pausing work: In many ways, this is similar to crash analysis: sometimes you need to shut down your machine in the middle of things and resume later, but you don't want to be forced to start from scratch because you have created an interesting scenario with data in the workspace. Saving a workspace allows you to do this. With the exception of the scenarios mentioned above, Link is intended to make it unnecessary to save workspaces. All source code changes that you make while editing or tracing your code should immediately end up in text files and be managed using an SCM. The normal workflow is to start each APL session by loading the code into the workspace from source directories. You might want to save a \"stub\" workspace that contains a very small amount of code that loads everything else from text source, but from version 18.0 of Dyalog APL you can now easily set that up using text files as well , rendering workspaces obsolete as part of your normal development workflow.","title":"Are Workspaces Dead Now?"},{"location":"Discussion/Workspaces/#saving-workspaces-containing-links","text":"If you )SAVE a workspace which has active links in it, this creates a potential conflict between the source code embedded in the workspace and any changes that may have been made to external source since the workspace was saved. If you )LOAD a saved workspace, Link will issue a warning along the lines of: IMPORTANT: 1 namespace linked in this workspace: #.myapp IMPORTANT: Link.Resync is required Except for a few reporting tools like Link.Status , link user commands and API functions will be disabled, until you run Link.Resync , which will compare the contents of the workspace and the source directories, list the differences and propose actions to take in order to bring the contents of the workspace in line with the source folders. Note Beware: If you continue working without doing a Resync, strange things may happen: Link user commands and API functions will refuse to perform any actions, but names defined in the linked namespace contain references to external source files that the interpreter and editor will still honour. Using the built-in editor will read the external source file at the start of an editing session, and any changes made will be written to file, even though Link itself remains disabled. In other words, you should NOT continue working without a Resync, unless you have a very good reason to do so and understand exactly what might happen.","title":"Saving workspaces containing Links"},{"location":"Discussion/Workspaces/#distribution","text":"If you want to distribute a workspace created using Link to import code, note that if the workspace is loaded on a machine where the recorded source file names are not valid, this will lead to confusion. Application workspaces should always be built using Link.Import . Alternatively, use Link.Break to remove the links before you )SAVE the workspace. Note If you automate a build process using Link.Create rather than Link.Import, immediately followed by a \u2395SAVE , there is a significant chance that a File System Watcher callback will be running in a separate thread, which will cause the \u2395SAVE to fail. See the discussion about setting up your environment for more tips on creating development and runtime environments.","title":"Distribution"},{"location":"Usage/","text":"Basic Usage These sections cover the most commonly used commands. For more advanced usage, please consult the API documentation . Starting from an existing folder containing text files Use Link.Create to Link a directory containing text source to a namespace in the active workspace. The following example loads APL code from the folder /users/sally/myapp into a namespace called myapp . \u2395SE.Link.Create myapp '/users/sally/myapp' For ad hoc use in an interactive session, it might be more convenient to use the user command: ]LINK.Create myapp /users/sally/myapp Linking a directory on startup If you are using Dyalog version 18.2 or later, you can cause a link to be created to the root of your workspace ( # ) as APL starts, by setting the LOAD parameter on the command line or as an environment variable. After establishing the link, the system will call the function Run with a right argument containing the name of the directory. You can disable the call to Run by including the -x switch on the command line (in the same way that the -x switch inhibits the execution of the latent expression when loading a workspace). With a standard Dyalog 18.2 installation under Microsoft Windows, you can also right click on a directory and select \"Open with Dyalog\" or \"Run with Dyalog\" to create a link on startup and optionally call Run . Importing code without creating a link Sometimes you want to load some code in order to run it, without intending to make any modifications - or you might want to experiment and make modifications to the code, but want to be sure that the source files are not updated. Use Link.Import to bring code from text source files into the active workspace without creating a link. The syntax of Import is almost identical to Create. The important difference being that changes to code in the workspace or in source files are not tracked or acted upon following an Import. For example: ]LINK.Import myapp /users/sally/myapp Starting a new project If you are starting a completely new project, you can either create a namespace in the active workspace, or a folder on the file system (or both), and use Link.Create , naming the namespace and the folder, as in the example at the start of this page. If neither of them exist, Link.Create will reject the request on suspicion that there is a typo, in order to avoid silently creating an empty directory by mistake. If both of them exist AND contain code, and the code is not identical on both sides, Link.Create will fail and you will need to specify the source option, whether the namespace or the directory should be considered to be the source. Incorrectly specifying the source will potentially overwrite existing content on the other side, so use this with extreme caution! To illustrate, we will create a namespace and populate it with two dfns and one tradfn, in order to have something to work with. In this example, the functions are created using APL expressions; under normal use the functions would probably be created using the editor, or perhaps loaded or copied from an existing workspace. 'stats' \u2395NS \u236c \u235d Create an empty namespace stats.\u2395FX 'mean\u2190Mean vals;sum' 'sum\u2190+\u233f,vals' 'mean\u2190sum\u00f71\u2308\u2374,vals' stats.Root\u2190{\u237a\u21902 \u22c4 \u2375*\u00f7\u237a} stats.StdDev\u2190{2 Root(+.\u00d7\u2368\u00f7\u2374),\u2375-Mean \u2375} We could now create a source directory using Link.Export , and then use Link.Create to create a link to it. However, Link.Create can do this in one step: assuming that the directory /users/sally/stats is empty or does not exist, the following command will detect that there is code in the namespace but not in the directory, and create a link based on the namespace that we just populated with our functions: ]LINK.Create stats /users/sally/stats Linked: #.stats \u2190\u2192 C:\\tmp\\stats The double arrow \u2190\u2192 in the output indicates that synchronisation is bi-directional. If .NET is not available, the default will be to only replicate changes in the namespace to file, which will be indicated by a \u2192 . We can check that the three expected files have been created: ls\u2190\u2395NINFO\u23601 \u235d List files, allowing wildcards ls '/users/sally/stats/*' /users/sally/stats/Mean.aplf /users/sally/stats/Root.aplf /users/sally/stats/StdDev.aplf We can also verify that the new source directory can be used to re-build the original namespace:: )CLEAR clear ws ]LINK.Create stats /users/sally/stats Linked: stats \u2190\u2192 users/sally/stats stats.\u2395NL -3 \u235d Verify functions were loaded as expected Mean Root StdDev Starting a project from a workspace If your existing code is in a workspace rather than in text files, you should read the section on converting a workspace to source files before continuing. Saving your work Once a link is set up using Link.Create , you can work with your code using the Dyalog exactly as you would if you were not using Link; the only difference being that Link will ensure that any changes you make (using the APL editor) to the code within the stats namespace are instantly copied to the corresponding source file. In the context of this document, the term Dyalog IDE includes both the Windows IDE and the Remote IDE (RIDE), which is tightly integrated with the interpreter. The use of a source code management system like Git is recommended. If you do that, then you effectively save your work by doing a commit. Conversely, if you are new to Dyalog APL, and have a favourite editor, you can use it to edit the source files directly, and any changes that you make will be replicated in the active workspace - assuming that .NET (Framework, or 6.0 and later versions) is available and your APL system is configured to use it. Note Note that, although a so-called .NET File System Watcher (FSW) is useful for immediately picking up changes made using an external editor, a FSW is NOT a reliable mechanism for deployment of new code to running systems. For example, running a server with an active link and patching it simply by modifying linked source files IS NOT RECOMMENDED . If you use editors inside or outside the APL system to add new functions, operators, namespaces or classes, the corresponding change will be made on the other side of the link. For example, we could add a Median function to the namespace we created earlier: )ED stats.Median In the Edit window, we complete the function: Median\u2190{ asc\u2190\u234bvals\u2190,\u2375 Mean vals[asc[\u23082\u00f7\u23680 1+\u2374vals]] } When the editor fixes the definition of the function in the workspace, Link will create a new file: ls '/users/sally/stats/*' /users/sally/stats/Mean.aplf /users/sally/stats/Root.aplf /users/sally/stats/StdDev.aplf /users/stats/StdDev.aplf Viewing the status of links The function (and corresponding user command) Link.Status will show namespaces that are currently linked and the folders to which they are linked. For example: ]link.status Namespace Source Files #.stats /users/sally/stats 4 Un-Linking a namespace To continue using code in the active workspace without the risk of updating text source files or picking up changes made using external editors, use Link.Break . Clearing the workspace, for example using )CLEAR , or exiting Dyalog, for example with )OFF , will also break all links in the active workspace. See the technical details on breaking links for more information, for example about what happens when you delete a linked namespace from the active workspace. Changes made outside the Editor When changes are made using the editor which is built-in to Dyalog APL (Windows IDE or RIDE), source files are updated immediately. Changes made outside the editor will not immediately be picked up. This includes: Definitions created or changed using assignment ( \u2190 ), \u2395FX or \u2395FIX . Definitions moved between workspaces or namespaces using \u2395CY , \u2395NS or )COPY . Definitions erased using \u2395EX or )ERASE If you write tools which modify source code under program control, such as linters or search/replace tools, you should call the API functions Link.Fix or Link.Expunge to update the definitions, so that Link can take appropriate action such as updating source files. If you update the source files under program control and inbound synchronisation is not enabled, you can use Link.Notify to let Link know about an external change that you would like to bring into the workspace. Arrays By default, Link does not consider arrays to be part of the source code of an application and will not write arrays to source files unless you explicitly request it. Link is not intended to be used as a database management system; if you have arrays that are modified during the normal running of your application, we recommend that you store that data in an RDBMS or other files that are managed by the application code, rather than using Link for this. However, if you have arrays that represent error tables, range definitions or other constant definitions that it makes sense to conside to be part of the source code, you can add them using Link.Add : stats.Directions\u2190'North' 'South' 'East' 'West' ]Link.Add stats.Directions Added: #.stats.Directions By default, Link uses APL Array Notation to store arrays in text files. Link 4.0 introduces experimental support for storing multi-line character data in simple text files. For more information, see the section on array formats . Once you have created a source file for an array, Link will update that file if you use the editor to modify the array. Only if you modify the array using assignment or other means than the editor will you need to call Link.Add to force an update of the source file. Changes made to source files, including the addition of new .apla files, will always be reflected in the workspace, if the link has been set up to watch the file system. Setting up Development and Runtime Environments We have seen how to use ]Link.Create to load textual source into the workspace in order to work with it. As your project grows, you will probably want to split your code into modules, for example application code in one directory and shared utilities in another - and maybe also run some code to get things set up. Next, we will look at Setting up Development and Runtime Environments , so that you don't have to type the same sequence of things over and over again to get started with development - or running the application.","title":"Basic Usage"},{"location":"Usage/#basic-usage","text":"These sections cover the most commonly used commands. For more advanced usage, please consult the API documentation .","title":"Basic Usage"},{"location":"Usage/#starting-from-an-existing-folder-containing-text-files","text":"Use Link.Create to Link a directory containing text source to a namespace in the active workspace. The following example loads APL code from the folder /users/sally/myapp into a namespace called myapp . \u2395SE.Link.Create myapp '/users/sally/myapp' For ad hoc use in an interactive session, it might be more convenient to use the user command: ]LINK.Create myapp /users/sally/myapp","title":"Starting from an existing folder containing text files"},{"location":"Usage/#linking-a-directory-on-startup","text":"If you are using Dyalog version 18.2 or later, you can cause a link to be created to the root of your workspace ( # ) as APL starts, by setting the LOAD parameter on the command line or as an environment variable. After establishing the link, the system will call the function Run with a right argument containing the name of the directory. You can disable the call to Run by including the -x switch on the command line (in the same way that the -x switch inhibits the execution of the latent expression when loading a workspace). With a standard Dyalog 18.2 installation under Microsoft Windows, you can also right click on a directory and select \"Open with Dyalog\" or \"Run with Dyalog\" to create a link on startup and optionally call Run .","title":"Linking a directory on startup"},{"location":"Usage/#importing-code-without-creating-a-link","text":"Sometimes you want to load some code in order to run it, without intending to make any modifications - or you might want to experiment and make modifications to the code, but want to be sure that the source files are not updated. Use Link.Import to bring code from text source files into the active workspace without creating a link. The syntax of Import is almost identical to Create. The important difference being that changes to code in the workspace or in source files are not tracked or acted upon following an Import. For example: ]LINK.Import myapp /users/sally/myapp","title":"Importing code without creating a link"},{"location":"Usage/#starting-a-new-project","text":"If you are starting a completely new project, you can either create a namespace in the active workspace, or a folder on the file system (or both), and use Link.Create , naming the namespace and the folder, as in the example at the start of this page. If neither of them exist, Link.Create will reject the request on suspicion that there is a typo, in order to avoid silently creating an empty directory by mistake. If both of them exist AND contain code, and the code is not identical on both sides, Link.Create will fail and you will need to specify the source option, whether the namespace or the directory should be considered to be the source. Incorrectly specifying the source will potentially overwrite existing content on the other side, so use this with extreme caution! To illustrate, we will create a namespace and populate it with two dfns and one tradfn, in order to have something to work with. In this example, the functions are created using APL expressions; under normal use the functions would probably be created using the editor, or perhaps loaded or copied from an existing workspace. 'stats' \u2395NS \u236c \u235d Create an empty namespace stats.\u2395FX 'mean\u2190Mean vals;sum' 'sum\u2190+\u233f,vals' 'mean\u2190sum\u00f71\u2308\u2374,vals' stats.Root\u2190{\u237a\u21902 \u22c4 \u2375*\u00f7\u237a} stats.StdDev\u2190{2 Root(+.\u00d7\u2368\u00f7\u2374),\u2375-Mean \u2375} We could now create a source directory using Link.Export , and then use Link.Create to create a link to it. However, Link.Create can do this in one step: assuming that the directory /users/sally/stats is empty or does not exist, the following command will detect that there is code in the namespace but not in the directory, and create a link based on the namespace that we just populated with our functions: ]LINK.Create stats /users/sally/stats Linked: #.stats \u2190\u2192 C:\\tmp\\stats The double arrow \u2190\u2192 in the output indicates that synchronisation is bi-directional. If .NET is not available, the default will be to only replicate changes in the namespace to file, which will be indicated by a \u2192 . We can check that the three expected files have been created: ls\u2190\u2395NINFO\u23601 \u235d List files, allowing wildcards ls '/users/sally/stats/*' /users/sally/stats/Mean.aplf /users/sally/stats/Root.aplf /users/sally/stats/StdDev.aplf We can also verify that the new source directory can be used to re-build the original namespace:: )CLEAR clear ws ]LINK.Create stats /users/sally/stats Linked: stats \u2190\u2192 users/sally/stats stats.\u2395NL -3 \u235d Verify functions were loaded as expected Mean Root StdDev","title":"Starting a new project"},{"location":"Usage/#starting-a-project-from-a-workspace","text":"If your existing code is in a workspace rather than in text files, you should read the section on converting a workspace to source files before continuing.","title":"Starting a project from a workspace"},{"location":"Usage/#saving-your-work","text":"Once a link is set up using Link.Create , you can work with your code using the Dyalog exactly as you would if you were not using Link; the only difference being that Link will ensure that any changes you make (using the APL editor) to the code within the stats namespace are instantly copied to the corresponding source file. In the context of this document, the term Dyalog IDE includes both the Windows IDE and the Remote IDE (RIDE), which is tightly integrated with the interpreter. The use of a source code management system like Git is recommended. If you do that, then you effectively save your work by doing a commit. Conversely, if you are new to Dyalog APL, and have a favourite editor, you can use it to edit the source files directly, and any changes that you make will be replicated in the active workspace - assuming that .NET (Framework, or 6.0 and later versions) is available and your APL system is configured to use it. Note Note that, although a so-called .NET File System Watcher (FSW) is useful for immediately picking up changes made using an external editor, a FSW is NOT a reliable mechanism for deployment of new code to running systems. For example, running a server with an active link and patching it simply by modifying linked source files IS NOT RECOMMENDED . If you use editors inside or outside the APL system to add new functions, operators, namespaces or classes, the corresponding change will be made on the other side of the link. For example, we could add a Median function to the namespace we created earlier: )ED stats.Median In the Edit window, we complete the function: Median\u2190{ asc\u2190\u234bvals\u2190,\u2375 Mean vals[asc[\u23082\u00f7\u23680 1+\u2374vals]] } When the editor fixes the definition of the function in the workspace, Link will create a new file: ls '/users/sally/stats/*' /users/sally/stats/Mean.aplf /users/sally/stats/Root.aplf /users/sally/stats/StdDev.aplf /users/stats/StdDev.aplf","title":"Saving your work"},{"location":"Usage/#viewing-the-status-of-links","text":"The function (and corresponding user command) Link.Status will show namespaces that are currently linked and the folders to which they are linked. For example: ]link.status Namespace Source Files #.stats /users/sally/stats 4","title":"Viewing the status of links"},{"location":"Usage/#un-linking-a-namespace","text":"To continue using code in the active workspace without the risk of updating text source files or picking up changes made using external editors, use Link.Break . Clearing the workspace, for example using )CLEAR , or exiting Dyalog, for example with )OFF , will also break all links in the active workspace. See the technical details on breaking links for more information, for example about what happens when you delete a linked namespace from the active workspace.","title":"Un-Linking a namespace"},{"location":"Usage/#changes-made-outside-the-editor","text":"When changes are made using the editor which is built-in to Dyalog APL (Windows IDE or RIDE), source files are updated immediately. Changes made outside the editor will not immediately be picked up. This includes: Definitions created or changed using assignment ( \u2190 ), \u2395FX or \u2395FIX . Definitions moved between workspaces or namespaces using \u2395CY , \u2395NS or )COPY . Definitions erased using \u2395EX or )ERASE If you write tools which modify source code under program control, such as linters or search/replace tools, you should call the API functions Link.Fix or Link.Expunge to update the definitions, so that Link can take appropriate action such as updating source files. If you update the source files under program control and inbound synchronisation is not enabled, you can use Link.Notify to let Link know about an external change that you would like to bring into the workspace.","title":"Changes made outside the Editor"},{"location":"Usage/#arrays","text":"By default, Link does not consider arrays to be part of the source code of an application and will not write arrays to source files unless you explicitly request it. Link is not intended to be used as a database management system; if you have arrays that are modified during the normal running of your application, we recommend that you store that data in an RDBMS or other files that are managed by the application code, rather than using Link for this. However, if you have arrays that represent error tables, range definitions or other constant definitions that it makes sense to conside to be part of the source code, you can add them using Link.Add : stats.Directions\u2190'North' 'South' 'East' 'West' ]Link.Add stats.Directions Added: #.stats.Directions By default, Link uses APL Array Notation to store arrays in text files. Link 4.0 introduces experimental support for storing multi-line character data in simple text files. For more information, see the section on array formats . Once you have created a source file for an array, Link will update that file if you use the editor to modify the array. Only if you modify the array using assignment or other means than the editor will you need to call Link.Add to force an update of the source file. Changes made to source files, including the addition of new .apla files, will always be reflected in the workspace, if the link has been set up to watch the file system.","title":"Arrays"},{"location":"Usage/#setting-up-development-and-runtime-environments","text":"We have seen how to use ]Link.Create to load textual source into the workspace in order to work with it. As your project grows, you will probably want to split your code into modules, for example application code in one directory and shared utilities in another - and maybe also run some code to get things set up. Next, we will look at Setting up Development and Runtime Environments , so that you don't have to type the same sequence of things over and over again to get started with development - or running the application.","title":"Setting up Development and Runtime Environments"},{"location":"Usage/Arrays/","text":"Array Formats By default, Link uses APL Array Notation (APLAN) to store arrays in text files. While APLAN is a good format for describing numeric data, nested arrays and many high rank arrays, it is not ideal for storing text data. Link 4.0 introduces experimental support for storing multi-line character data in simple text files. The configuration setting text can be used to enable this feature: If text is set to 'aplan' (the default) then all arrays will be store using APLAN. If text is set to 'plain' then text arrays that adhere to a set of very specific criteria will instead be stored in plain text files. You can set this option when a link is created, or using Link.Configure . Text files which are not in APLAN format will have a penultimate \"sub-extension\" section in the file name which records the format of the original array in the workspace. The below table describes the array file extensions, what the content represents, and the specific criteria for storage in plain text file. For all plain text types, the array must be non-empty. File Extension Array Characteristics Prohibited characters ( \u2395UCS ) .CR.apla Simple vector with each line terminated by \u2395UCS 13 10 11 12 133 8232 8233 .LF.apla Simple vector with each line terminated by \u2395UCS 10 11 12 13 133 8232 8233 .CRLF.apla Simple vector with each line terminated by \u2395UCS 13 10 11 12 133 8232 8233 * .vec.apla Vector of simple character vectors (no scalar elements) 11 12 13 133 8232 8233 .mat.apla Simple character matrix 10 11 12 13 133 8232 8233 * In addition, every occurring \u2395UCS 10 must be immediately preceded by a \u2395UCS 13 and every occurring \u2395UCS 13 must be immediately followed by \u2395UCS 10 . In all other cases, the extension will be just .apla and the file will contain APLAN that can represent any APL array.","title":"Array Formats"},{"location":"Usage/Arrays/#array-formats","text":"By default, Link uses APL Array Notation (APLAN) to store arrays in text files. While APLAN is a good format for describing numeric data, nested arrays and many high rank arrays, it is not ideal for storing text data. Link 4.0 introduces experimental support for storing multi-line character data in simple text files. The configuration setting text can be used to enable this feature: If text is set to 'aplan' (the default) then all arrays will be store using APLAN. If text is set to 'plain' then text arrays that adhere to a set of very specific criteria will instead be stored in plain text files. You can set this option when a link is created, or using Link.Configure . Text files which are not in APLAN format will have a penultimate \"sub-extension\" section in the file name which records the format of the original array in the workspace. The below table describes the array file extensions, what the content represents, and the specific criteria for storage in plain text file. For all plain text types, the array must be non-empty. File Extension Array Characteristics Prohibited characters ( \u2395UCS ) .CR.apla Simple vector with each line terminated by \u2395UCS 13 10 11 12 133 8232 8233 .LF.apla Simple vector with each line terminated by \u2395UCS 10 11 12 13 133 8232 8233 .CRLF.apla Simple vector with each line terminated by \u2395UCS 13 10 11 12 133 8232 8233 * .vec.apla Vector of simple character vectors (no scalar elements) 11 12 13 133 8232 8233 .mat.apla Simple character matrix 10 11 12 13 133 8232 8233 * In addition, every occurring \u2395UCS 10 must be immediately preceded by a \u2395UCS 13 and every occurring \u2395UCS 13 must be immediately followed by \u2395UCS 10 . In all other cases, the extension will be just .apla and the file will contain APLAN that can represent any APL array.","title":"Array Formats"},{"location":"Usage/ConfigFiles/","text":"Configuration Files Introduction Link Configuration files are in JSON5 format , which is the same format as Dyalog APL configuration files. There is a user configuration file containing options that apply to all links, and directory configuraton files which apply to individual directories. When performing an action that is related to a directory, Link will read both the user and directory configurations. If a setting is found in both places, the more specific directory setting will override the general user settting. User Configuration Files You can have a user configuration file called .linkconfig , which records preferences that apply to all links, for example link creation options like -watch= or the notify setting. Under Microsoft Windows, this file is stored in the Documents folder, on other systems in the user's home directory. A simple example of a user configuration file would be: { LinkVersion: { ID: \"4.0.11\"}, Debug: { notify: 1, }, Settings: { watch: \"ns\", }, } With the above user configuration file contents, Link will display notifications when processing changes to the source (notify:1), and default to only propagating changes from the namespace to source files (watch:ns). If a call to Link.Create includes an explicit setting of the watch option, that will override the default. Note that a configuration contains a LinkVersion section, which identifies the version of Link that wrote the file. Directory Configuration Files Each linked directory may contain a .linkconfig file containing defaults that will apply when a link is created to that directory, or if the directory is imported. When Link.Create or Link.Export create a directory and create files in it, any non-default switch settings provided to tha API function will be recorded in a configuration file within the directory. This means that you no longer need to remember the options used to re-create the original link when continuing work, or importing the link into a runtime environment. If you already have a Link folder which was created by an earlier version of Link, you can add a .linkconfig file using Link.Configure . For example: ]Link.Create linkdemo /tmp/linkdemo ]Link.Configure linkdemo flatten:1 Was flatten: The result documents that there was no previous setting for the option. A file called /tmp/linkdemo/.linkconfig is created, with the following contents: { LinkVersion: { ID: \"4.0.11\"}, Settings: { flatten: 1, }, } Stop and Trace flags Directory configuration files also record stop and trace settings for functions and operators in the linked directory, which you can either manipulate in the editor, or using the API functions Link.Stop and Link.Trace : ]link.stop linkdemo.stats.Mean 2 Was linkdemo.stats.Mean 1 These settings are recorded in a SourceFlags section of our configuration file, which now looks like this: { LinkVersion: { ID: \"4.0.11\"}, Settings: { flatten: 1, }, SourceFlags: [ { Name: \"stats.Mean\", Stop: [ 2, ], }, ], } Note that there is no support for storing \u2395MONITOR settings, as these are usually set under program control and used for reporting. Link.Configure The Link.Configure API function and the corresponding user command, can be used to query and set the contents of both user and directory configuration files. For example, following on from the above example, we can query the current settings: ]link.configure linkdemo Contents of \"c:/tmp/linkdemo/.linkconfig\": Settings : flatten:1 ]link.configure * Contents of \"C:\\Users\\mkrom\\Documents\\.linkconfig\": Debug : notify:1 Settings : watch:ns You can change the settings by adding name:value pairs, and completely remove a setting by putting nothing after the colon: ]link.configure linkdemo flatten:0 Was flatten:1 ]link.configure linkdemo Contents of \"c:/tmp/linkdemo/.linkconfig\": Settings : flatten:0 ]link.configure linkdemo flatten: Was flatten:1 ]link.configure linkdemo No configuration options set in \"c:/tmp/linkdemo/.linkconfig\" The Configuration File Format User and directory configuration files have the same format, with up to four top level names: LinkVersion identifies the version of Link that wrote the file. Settings This section can contain settings for most Link API function options. For a complete list, see the documentation for Link.Create . Debug This section can contain two settings, debug and notify that assist with debugging Link, they are primarily aimed at Link Developers or expert APL users who believe Link might be misbehaving. debug:1 Disables error trapping within Link API functions debug:2 Stops at the beginning of each Link API call, to facilitate tracing notify:1 Causes Link to write confirmation to the APL session each time it defines a function SourceFlags Unlike Debug and Settings, SourceFlags is an array with one element per function or operator which has saved Stop and Trace settings. Each array element will contain a Name property, which is the name of the function or operator, and it may contain Stop and Trace, which are integer vectors containing line numbers. An example of a configuration file with information in all sections is: { LinkVersion: { ID: \"4.0.11\"}, Debug: { notify:1, }, Settings: { watch: \"ns\"1, }, SourceFlags: [ { Name: \"stats.Mean\", Stop: [ 2, ], }, ], } The ignoreconfig switch If you manually edit a .linkconfig file and damage it so that it either becomes invalid JSON5 so that Link is unable to read it, or if Link is able to read it but complains that it has invalid contents, or if you simply want to ignore the configuration for other reasons, several API functions including Create, Import and Export have an ignoreconfig option: ]link.create linkdemo c:\\tmp\\linkdemo Unknown Setting(s) in \"c:\\tmp\\linkdemo/.linkconfig\": fasten ]link.create linkdemo c:\\tmp\\linkdemo -ignoreconfig Linked: #.linkdemo \u2190\u2192 c:\\tmp\\linkdemo","title":"Configuration Files"},{"location":"Usage/ConfigFiles/#configuration-files","text":"","title":"Configuration Files"},{"location":"Usage/ConfigFiles/#introduction","text":"Link Configuration files are in JSON5 format , which is the same format as Dyalog APL configuration files. There is a user configuration file containing options that apply to all links, and directory configuraton files which apply to individual directories. When performing an action that is related to a directory, Link will read both the user and directory configurations. If a setting is found in both places, the more specific directory setting will override the general user settting.","title":"Introduction"},{"location":"Usage/ConfigFiles/#user-configuration-files","text":"You can have a user configuration file called .linkconfig , which records preferences that apply to all links, for example link creation options like -watch= or the notify setting. Under Microsoft Windows, this file is stored in the Documents folder, on other systems in the user's home directory. A simple example of a user configuration file would be: { LinkVersion: { ID: \"4.0.11\"}, Debug: { notify: 1, }, Settings: { watch: \"ns\", }, } With the above user configuration file contents, Link will display notifications when processing changes to the source (notify:1), and default to only propagating changes from the namespace to source files (watch:ns). If a call to Link.Create includes an explicit setting of the watch option, that will override the default. Note that a configuration contains a LinkVersion section, which identifies the version of Link that wrote the file.","title":"User Configuration Files"},{"location":"Usage/ConfigFiles/#directory-configuration-files","text":"Each linked directory may contain a .linkconfig file containing defaults that will apply when a link is created to that directory, or if the directory is imported. When Link.Create or Link.Export create a directory and create files in it, any non-default switch settings provided to tha API function will be recorded in a configuration file within the directory. This means that you no longer need to remember the options used to re-create the original link when continuing work, or importing the link into a runtime environment. If you already have a Link folder which was created by an earlier version of Link, you can add a .linkconfig file using Link.Configure . For example: ]Link.Create linkdemo /tmp/linkdemo ]Link.Configure linkdemo flatten:1 Was flatten: The result documents that there was no previous setting for the option. A file called /tmp/linkdemo/.linkconfig is created, with the following contents: { LinkVersion: { ID: \"4.0.11\"}, Settings: { flatten: 1, }, }","title":"Directory Configuration Files"},{"location":"Usage/ConfigFiles/#stop-and-trace-flags","text":"Directory configuration files also record stop and trace settings for functions and operators in the linked directory, which you can either manipulate in the editor, or using the API functions Link.Stop and Link.Trace : ]link.stop linkdemo.stats.Mean 2 Was linkdemo.stats.Mean 1 These settings are recorded in a SourceFlags section of our configuration file, which now looks like this: { LinkVersion: { ID: \"4.0.11\"}, Settings: { flatten: 1, }, SourceFlags: [ { Name: \"stats.Mean\", Stop: [ 2, ], }, ], } Note that there is no support for storing \u2395MONITOR settings, as these are usually set under program control and used for reporting.","title":"Stop and Trace flags"},{"location":"Usage/ConfigFiles/#linkconfigure","text":"The Link.Configure API function and the corresponding user command, can be used to query and set the contents of both user and directory configuration files. For example, following on from the above example, we can query the current settings: ]link.configure linkdemo Contents of \"c:/tmp/linkdemo/.linkconfig\": Settings : flatten:1 ]link.configure * Contents of \"C:\\Users\\mkrom\\Documents\\.linkconfig\": Debug : notify:1 Settings : watch:ns You can change the settings by adding name:value pairs, and completely remove a setting by putting nothing after the colon: ]link.configure linkdemo flatten:0 Was flatten:1 ]link.configure linkdemo Contents of \"c:/tmp/linkdemo/.linkconfig\": Settings : flatten:0 ]link.configure linkdemo flatten: Was flatten:1 ]link.configure linkdemo No configuration options set in \"c:/tmp/linkdemo/.linkconfig\"","title":"Link.Configure"},{"location":"Usage/ConfigFiles/#the-configuration-file-format","text":"User and directory configuration files have the same format, with up to four top level names: LinkVersion identifies the version of Link that wrote the file. Settings This section can contain settings for most Link API function options. For a complete list, see the documentation for Link.Create . Debug This section can contain two settings, debug and notify that assist with debugging Link, they are primarily aimed at Link Developers or expert APL users who believe Link might be misbehaving. debug:1 Disables error trapping within Link API functions debug:2 Stops at the beginning of each Link API call, to facilitate tracing notify:1 Causes Link to write confirmation to the APL session each time it defines a function SourceFlags Unlike Debug and Settings, SourceFlags is an array with one element per function or operator which has saved Stop and Trace settings. Each array element will contain a Name property, which is the name of the function or operator, and it may contain Stop and Trace, which are integer vectors containing line numbers. An example of a configuration file with information in all sections is: { LinkVersion: { ID: \"4.0.11\"}, Debug: { notify:1, }, Settings: { watch: \"ns\"1, }, SourceFlags: [ { Name: \"stats.Mean\", Stop: [ 2, ], }, ], }","title":"The Configuration File Format"},{"location":"Usage/ConfigFiles/#the-ignoreconfig-switch","text":"If you manually edit a .linkconfig file and damage it so that it either becomes invalid JSON5 so that Link is unable to read it, or if Link is able to read it but complains that it has invalid contents, or if you simply want to ignore the configuration for other reasons, several API functions including Create, Import and Export have an ignoreconfig option: ]link.create linkdemo c:\\tmp\\linkdemo Unknown Setting(s) in \"c:\\tmp\\linkdemo/.linkconfig\": fasten ]link.create linkdemo c:\\tmp\\linkdemo -ignoreconfig Linked: #.linkdemo \u2190\u2192 c:\\tmp\\linkdemo","title":"The ignoreconfig switch"},{"location":"Usage/Installation/","text":"Installation Link 4.0 is included with Dyalog version 19.0 or later, and is supported for use with version 18.2. Note For Dyalog to automatically update workspace contents in response to changes to files made using external editors or source code management systems, .NET must be installed. The .NET Framework is included with Microsoft Windows. For other platforms, .NET can be downloaded from dotnet.microsoft.com/download . Link 4.0 has been tested with the .NET Framework version 4 and .NET versions 6 and 8, and is expected to work with any later version of .NET. The instructions on this page only apply if you want to user a different release than that which is distributed with your version of Dyalog APL. Note If you use a non-standard Dyalog session (.dse file), contact support@dyalog.com for guidance on enabling Link. Instructions Link is maintained as an open source project at github.com/dyalog/link . Start by downloading one of the zip files included with the latest release of Link 4.0 from github.com/Dyalog/link/releases . If you are using Dyalog version 19.0 or later, use the file named link-v4.0.nn.zip ; Extract the subfolder called StartupSession , which contains the code required to run Link. If you have version 18.2 , follow the same instructions, but use the zip file with the suffix -v182 . This file also contains code that is used to populate the \u2395SE.Dyalog namespace, it is required because Link 3.0 included this code, which has moved to a separate repository. If you have the necessary permissions, you can OVERWRITE the installed version of Link by replacing the StartupSession folder that already exists in the main Dyalog program folder with the downloaded folder. If you do not have permission to overwrite the Dyalog installation, or you do not wish to overwrite the original version of Link that was included with the interpreter (Dyalog recommends keeping the original code in case you need to fall back), you can keep the code outside the main program folder. In this case, you will need to declare the location of the folder by setting the parameter DYALOGLINK (v19.0 or later), or DYALOGSTARTUPSE (v18.2). You can add it to the command line when you start APL, but it is probably easier to use one of the following alternatives: Set the DYALOGLINK or DYALOGSTARTUPSE environment variable to identify the location of Link. Unfortunately the way this is done changed between 18.2 and 19.0: Update the configuration file (or the Windows registry) , to set the parameter there. Typically, you would edit ~/.dyalog/dyalog.config to make the change for all versions, or a specific file such as ~/.dyalog/dyalog.182U64.dcfg for a specific version, to include the line: `DYALOGLINK: \"/Users/mkrom/link\"` (version 19.0 or later - point to the parent of StartupSession) `DYALOGSTARTUPSE: \"/Users/mkrom/link/StartupSession\"` (version 18.2 - point to StartupSession itself) Note that you should use the full name of the path. Finally, refresh the User Command Cache using the ]ureset user command, to pick up any changes to user command definitions.","title":"Installation"},{"location":"Usage/Installation/#installation","text":"Link 4.0 is included with Dyalog version 19.0 or later, and is supported for use with version 18.2. Note For Dyalog to automatically update workspace contents in response to changes to files made using external editors or source code management systems, .NET must be installed. The .NET Framework is included with Microsoft Windows. For other platforms, .NET can be downloaded from dotnet.microsoft.com/download . Link 4.0 has been tested with the .NET Framework version 4 and .NET versions 6 and 8, and is expected to work with any later version of .NET. The instructions on this page only apply if you want to user a different release than that which is distributed with your version of Dyalog APL. Note If you use a non-standard Dyalog session (.dse file), contact support@dyalog.com for guidance on enabling Link.","title":"Installation"},{"location":"Usage/Installation/#instructions","text":"Link is maintained as an open source project at github.com/dyalog/link . Start by downloading one of the zip files included with the latest release of Link 4.0 from github.com/Dyalog/link/releases . If you are using Dyalog version 19.0 or later, use the file named link-v4.0.nn.zip ; Extract the subfolder called StartupSession , which contains the code required to run Link. If you have version 18.2 , follow the same instructions, but use the zip file with the suffix -v182 . This file also contains code that is used to populate the \u2395SE.Dyalog namespace, it is required because Link 3.0 included this code, which has moved to a separate repository. If you have the necessary permissions, you can OVERWRITE the installed version of Link by replacing the StartupSession folder that already exists in the main Dyalog program folder with the downloaded folder. If you do not have permission to overwrite the Dyalog installation, or you do not wish to overwrite the original version of Link that was included with the interpreter (Dyalog recommends keeping the original code in case you need to fall back), you can keep the code outside the main program folder. In this case, you will need to declare the location of the folder by setting the parameter DYALOGLINK (v19.0 or later), or DYALOGSTARTUPSE (v18.2). You can add it to the command line when you start APL, but it is probably easier to use one of the following alternatives: Set the DYALOGLINK or DYALOGSTARTUPSE environment variable to identify the location of Link. Unfortunately the way this is done changed between 18.2 and 19.0: Update the configuration file (or the Windows registry) , to set the parameter there. Typically, you would edit ~/.dyalog/dyalog.config to make the change for all versions, or a specific file such as ~/.dyalog/dyalog.182U64.dcfg for a specific version, to include the line: `DYALOGLINK: \"/Users/mkrom/link\"` (version 19.0 or later - point to the parent of StartupSession) `DYALOGSTARTUPSE: \"/Users/mkrom/link/StartupSession\"` (version 18.2 - point to StartupSession itself) Note that you should use the full name of the path. Finally, refresh the User Command Cache using the ]ureset user command, to pick up any changes to user command definitions.","title":"Instructions"},{"location":"Usage/Setup/","text":"Setting Up Your Application With a small project, you can get by using Link.Create or Link.Import to bring your source into the workspace in order to work with it. However, even in a small project, this quickly gets tedious, and as the project grows, you may want to load code from more that one directory, and perhaps run some code in order to set things up or even start the application. Eventually, you may want to look at a project management system like Cider , but that's a different story. Until you reach that point, you can use the Link API to automate the loading and running of your application. Example To illustrate, we will create a small application that uses the stats library that we created in the section on basic usage . We will put the application into a namespace called linkdemo : )clear clear ws )ns linkdemo ]link.create linkdemo /users/sally/linkdemo Linked: #.linkdemo \u2190\u2192 /users/sally/linkdemo )ed linkdemo.Main Our application is going to prompt the user for an input array and output the mean and standard deviation of the data, until the user inputs an empty array. Obviously, the code should be enhanced to validate the input and perhaps trap errors, but that is left as an exercise for the reader. \u2207 Main;data [1] \u235d Compute Mean and StdDev until user inputs an empty array [2] [3] :Repeat [4] \u2395\u2190'Enter some numbers:' [5] :If 0\u2260\u2374data\u2190\u2395 [6] \u2395\u2190'Mean: ',1\u2355#.stats.Mean data [7] \u2395\u2190'StdDev: ',1\u2355#.stats.StdDev data [8] :EndIf [9] :Until 0=\u2262data \u2207 We will need the stats code in the workspace as well, of course. Since we only intend to use it and don't want to risk making changes to its source code while testing our own application, we will use ]link.import rather than ]link.create to bring that code into the workspace. Note that after the import, ]link.status still only reports a single link: ]link.import stats /users/sally/stats Imported: #.stats \u2190 /users/tmp/stats ]link.status Namespace Directory Files #.linkdemo /users/sally/linkdemo 1 linkdemo.Main Enter some numbers: \u2395: 50+?100\u2374100 Mean: 102.4 StdDev: 30.1 Enter some numbers: \u2395: \u236c Automating Startup Starting with Dyalog APL version 18.0, it is simple to launch the interpreter from a text file: either a source file defining a function, namespace or class using the LOAD parameter or from a configuration file using the CONFIGFILE parameter . From version 18.2, LOAD can also indentify a directory, in which case APL will create a link to the directory on startup, and attempt to call the function #.Run , with the enclosed name of the directory as the right argument. You can skip or replace the call to Run by adding LX= to your command line. Using LOAD to link to a directory on startup is simple way to handle very simple applications or ad-hoc development. However, configuration files allow you to both set a startup expression and include other configuration options for the interpreter and are probably a better solution for applications consisting of more than one source directory. For example, we could start our example application by creating a file dev.dcfg in the linkdemo folder with the following contents: { Settings: { MAXWS: \"100M\", LX: \"linkdemo.Start 0 \u22a3 \u2395\u2190\u2395SE.Link.Create 'linkdemo' \u2395SE.Link.LaunchDir\" } } This specifies an APL session with a MAXWS of 100 megabytes, which will start by creating the linkdemo namespace and calling linkdemo.Start . The namespace will be created using the directory named by the result of the function \u2395SE.Link.LaunchDir ; this will be the directory that the CONFIGFILE parameter refers to (or, if there is no CONFIGFILE, the directory referred to by the LOAD parameter). The function linkdemo.Start will bring in the stats library using Link.Import : since we are not developers of this library, we don't want to create a bi-directional link that might allow us to accidentally modify it during our testing. It also creates the name ST to point to the stats library, which means that our Main function can use more pleasant names, like ST.Mean in place of #.stats.Mean - which also makes it easier to relocate that module in the workspace: \u2207 Start run [1] \u235d Establish development environment for the linkdemo application [2] [3] \u2395IO\u2190\u2395ML\u21901 [4] \u2395SE.Link.Import '#.stats' '/users/sally/stats' \u235d Load the stats library [5] ST\u2190#.stats [6] :If run [7] Main [8] \u2395OFF [9] :EndIf \u2207 We can now launch our development environment using dyalog CONFIGFILE=linkdemo/devt.cfg , or on some platforms right-clicking on this file and selecting Run. Development vs Runtime The Start function takes a right argument run which decides whether it should just exit after initialising the environment, or it should launch the application by calling Main and terminate the session when the user decides that the job is done. This allows us to create a second configuration file, linkdemo/run.dcfg , which differs from dev.dcfg in that we reserve a bigger workspace (since we'll be doing real work rather than just testing), and brings the source code in using Link.Import rather than Link.Create , which means that we won't waste resources setting up a file system watcher, and that accidental changes made by anyone running the application will not update the source files. { Settings: { MAXWS: \"1G\", LX: \"linkdemo.Start 1 \u22a3 \u2395\u2190\u2395SE.Link.Import 'linkdemo' \u2395SE.Link.LaunchDir\" } } Distribution Workspace As we have seen, Link allows you to run your application based entirely on textual source files. However, if you have a lot of source files it may be more convenient for the users of your application to receive a single workspace file with all of the source loaded. To prepare a workspace for shipment, we will need to: Set \u2395LX in the so that it calls the Start function Use Link.Break to remove links to the source files. If you omit this step, you can create an extremely confusing situation . )SAVE the workspace Scripted Applications Recent versions of Dyalog APL support running APL from a script either by redirecting input to a normal APL interpreter or (recommended from version 18.2) using the new script engine. When the interpreter is running from a script, it intentionally provides you with a completely clean environment without any development tools loaded. This means that the session namespace is not populated, and Link is not loaded. If you add the following line to the top of your script, it will (amongst other things) bring Link into the session so that the API becomes available: #! dyalogscript DYALOG_INITSESSION=1","title":"Setting Up Your Application"},{"location":"Usage/Setup/#setting-up-your-application","text":"With a small project, you can get by using Link.Create or Link.Import to bring your source into the workspace in order to work with it. However, even in a small project, this quickly gets tedious, and as the project grows, you may want to load code from more that one directory, and perhaps run some code in order to set things up or even start the application. Eventually, you may want to look at a project management system like Cider , but that's a different story. Until you reach that point, you can use the Link API to automate the loading and running of your application.","title":"Setting Up Your Application"},{"location":"Usage/Setup/#example","text":"To illustrate, we will create a small application that uses the stats library that we created in the section on basic usage . We will put the application into a namespace called linkdemo : )clear clear ws )ns linkdemo ]link.create linkdemo /users/sally/linkdemo Linked: #.linkdemo \u2190\u2192 /users/sally/linkdemo )ed linkdemo.Main Our application is going to prompt the user for an input array and output the mean and standard deviation of the data, until the user inputs an empty array. Obviously, the code should be enhanced to validate the input and perhaps trap errors, but that is left as an exercise for the reader. \u2207 Main;data [1] \u235d Compute Mean and StdDev until user inputs an empty array [2] [3] :Repeat [4] \u2395\u2190'Enter some numbers:' [5] :If 0\u2260\u2374data\u2190\u2395 [6] \u2395\u2190'Mean: ',1\u2355#.stats.Mean data [7] \u2395\u2190'StdDev: ',1\u2355#.stats.StdDev data [8] :EndIf [9] :Until 0=\u2262data \u2207 We will need the stats code in the workspace as well, of course. Since we only intend to use it and don't want to risk making changes to its source code while testing our own application, we will use ]link.import rather than ]link.create to bring that code into the workspace. Note that after the import, ]link.status still only reports a single link: ]link.import stats /users/sally/stats Imported: #.stats \u2190 /users/tmp/stats ]link.status Namespace Directory Files #.linkdemo /users/sally/linkdemo 1 linkdemo.Main Enter some numbers: \u2395: 50+?100\u2374100 Mean: 102.4 StdDev: 30.1 Enter some numbers: \u2395: \u236c","title":"Example"},{"location":"Usage/Setup/#automating-startup","text":"Starting with Dyalog APL version 18.0, it is simple to launch the interpreter from a text file: either a source file defining a function, namespace or class using the LOAD parameter or from a configuration file using the CONFIGFILE parameter . From version 18.2, LOAD can also indentify a directory, in which case APL will create a link to the directory on startup, and attempt to call the function #.Run , with the enclosed name of the directory as the right argument. You can skip or replace the call to Run by adding LX= to your command line. Using LOAD to link to a directory on startup is simple way to handle very simple applications or ad-hoc development. However, configuration files allow you to both set a startup expression and include other configuration options for the interpreter and are probably a better solution for applications consisting of more than one source directory. For example, we could start our example application by creating a file dev.dcfg in the linkdemo folder with the following contents: { Settings: { MAXWS: \"100M\", LX: \"linkdemo.Start 0 \u22a3 \u2395\u2190\u2395SE.Link.Create 'linkdemo' \u2395SE.Link.LaunchDir\" } } This specifies an APL session with a MAXWS of 100 megabytes, which will start by creating the linkdemo namespace and calling linkdemo.Start . The namespace will be created using the directory named by the result of the function \u2395SE.Link.LaunchDir ; this will be the directory that the CONFIGFILE parameter refers to (or, if there is no CONFIGFILE, the directory referred to by the LOAD parameter). The function linkdemo.Start will bring in the stats library using Link.Import : since we are not developers of this library, we don't want to create a bi-directional link that might allow us to accidentally modify it during our testing. It also creates the name ST to point to the stats library, which means that our Main function can use more pleasant names, like ST.Mean in place of #.stats.Mean - which also makes it easier to relocate that module in the workspace: \u2207 Start run [1] \u235d Establish development environment for the linkdemo application [2] [3] \u2395IO\u2190\u2395ML\u21901 [4] \u2395SE.Link.Import '#.stats' '/users/sally/stats' \u235d Load the stats library [5] ST\u2190#.stats [6] :If run [7] Main [8] \u2395OFF [9] :EndIf \u2207 We can now launch our development environment using dyalog CONFIGFILE=linkdemo/devt.cfg , or on some platforms right-clicking on this file and selecting Run.","title":"Automating Startup"},{"location":"Usage/Setup/#development-vs-runtime","text":"The Start function takes a right argument run which decides whether it should just exit after initialising the environment, or it should launch the application by calling Main and terminate the session when the user decides that the job is done. This allows us to create a second configuration file, linkdemo/run.dcfg , which differs from dev.dcfg in that we reserve a bigger workspace (since we'll be doing real work rather than just testing), and brings the source code in using Link.Import rather than Link.Create , which means that we won't waste resources setting up a file system watcher, and that accidental changes made by anyone running the application will not update the source files. { Settings: { MAXWS: \"1G\", LX: \"linkdemo.Start 1 \u22a3 \u2395\u2190\u2395SE.Link.Import 'linkdemo' \u2395SE.Link.LaunchDir\" } }","title":"Development vs Runtime"},{"location":"Usage/Setup/#distribution-workspace","text":"As we have seen, Link allows you to run your application based entirely on textual source files. However, if you have a lot of source files it may be more convenient for the users of your application to receive a single workspace file with all of the source loaded. To prepare a workspace for shipment, we will need to: Set \u2395LX in the so that it calls the Start function Use Link.Break to remove links to the source files. If you omit this step, you can create an extremely confusing situation . )SAVE the workspace","title":"Distribution Workspace"},{"location":"Usage/Setup/#scripted-applications","text":"Recent versions of Dyalog APL support running APL from a script either by redirecting input to a normal APL interpreter or (recommended from version 18.2) using the new script engine. When the interpreter is running from a script, it intentionally provides you with a completely clean environment without any development tools loaded. This means that the session namespace is not populated, and Link is not loaded. If you add the following line to the top of your script, it will (amongst other things) bring Link into the session so that the API becomes available: #! dyalogscript DYALOG_INITSESSION=1","title":"Scripted Applications"},{"location":"Usage/WStoLink/","text":"Converting an Existing Workspace to use Link In order to start using Link to maintain code that resides in a workspace, you first need to export the code in the workspace to one or more folders. The simplest way to do this is to use Link.Export . In principle, it should be possible to write the entire contents of any workspace to an empty folder called /folder/name using the following: 'options' \u2395NS \u236c options.(arrays sysVars)\u21901 options \u2395SE.Link.Export # '/folder/name' or equivalently, using the user command: ]link.export # /folder/name -arrays -sysvars You can also use Link.Create with the same arguments, if you want an active link to exist after the export has been done. Options -arrays By default, Link assumes that the \"source code\" only consists of functions, operators, namespaces and classes. Variables are assumed to contain data which is transient and thus not part of the source. The -arrays causes all arrays in the workspace to be written to source files as well. You can also write selected variables to file, see the documentation for Link.Create for more options. -sysVars By default, Link will assume that you do not wish to record the settings for system variables, because your source will be loaded into an environment that already has the desired settings. If you want to be 100% sure to re-create your workspace exactly as it is, you can use -sysVars to record the values of system variables from each namespace in source files. Beware that this will add a lot of mostly redundant files to your repository. It is probably a better idea to analyse your workspace carefully and only write system variables to file if you really need them, using Link.Add . Workspaces containing Namespaces If your workspace is logically divided up into namespaces and you are happy for them all to end up in the same directory, you can use a single call to Link.Export or Link.Create like the one at the beginning of this section to write everything out at once. If you don't want the workspace to end up as a single directory tree, you can either restructure things afterwards using file explorers or command line tools, or you can make several separate calls to Export or Create to write the contents of individual namespaces to different locations. Of course, if you create more than one source directory, you will need make more than one call to Link.Create or Link.Import in order to re-create the workspace in order to run your code. Flat Workspaces and the -flatten Switch If your workspace is not divided into namespaces, but all your code and data are in the root (or #) namespace, it probably still consists of more than logically distinct sets of code (\"modules\"), that you might wish to manage separately. If you Export such a workspace, all the source files will obviously end up in the same folder. If you subsequently separate the source files into separate folders in order to make the source more manageable, you can still load it all into a single \"flat\" namespace using the -flatten switch. This allows the code to run unchanged, although you have created a structure for the source. The mappings to source files will be recorded, so that synchronisation will work if you edit the code in the APL system or using an external editor. If you create a new name inside the workspace, Link will obviously not know which folder to write it to, and will prompt you to specify a target folder. Recreating the Workspace In order to recreate the workspace from source, you will need to make one or more calls to Link.Create or Link.Import , depending on the structure that you have created. For some ideas on how to set this up, see Setting up your Environment .","title":"Converting an Existing Workspace to use Link"},{"location":"Usage/WStoLink/#converting-an-existing-workspace-to-use-link","text":"In order to start using Link to maintain code that resides in a workspace, you first need to export the code in the workspace to one or more folders. The simplest way to do this is to use Link.Export . In principle, it should be possible to write the entire contents of any workspace to an empty folder called /folder/name using the following: 'options' \u2395NS \u236c options.(arrays sysVars)\u21901 options \u2395SE.Link.Export # '/folder/name' or equivalently, using the user command: ]link.export # /folder/name -arrays -sysvars You can also use Link.Create with the same arguments, if you want an active link to exist after the export has been done.","title":"Converting an Existing Workspace to use Link"},{"location":"Usage/WStoLink/#options","text":"","title":"Options"},{"location":"Usage/WStoLink/#-arrays","text":"By default, Link assumes that the \"source code\" only consists of functions, operators, namespaces and classes. Variables are assumed to contain data which is transient and thus not part of the source. The -arrays causes all arrays in the workspace to be written to source files as well. You can also write selected variables to file, see the documentation for Link.Create for more options.","title":"-arrays"},{"location":"Usage/WStoLink/#-sysvars","text":"By default, Link will assume that you do not wish to record the settings for system variables, because your source will be loaded into an environment that already has the desired settings. If you want to be 100% sure to re-create your workspace exactly as it is, you can use -sysVars to record the values of system variables from each namespace in source files. Beware that this will add a lot of mostly redundant files to your repository. It is probably a better idea to analyse your workspace carefully and only write system variables to file if you really need them, using Link.Add .","title":"-sysVars"},{"location":"Usage/WStoLink/#workspaces-containing-namespaces","text":"If your workspace is logically divided up into namespaces and you are happy for them all to end up in the same directory, you can use a single call to Link.Export or Link.Create like the one at the beginning of this section to write everything out at once. If you don't want the workspace to end up as a single directory tree, you can either restructure things afterwards using file explorers or command line tools, or you can make several separate calls to Export or Create to write the contents of individual namespaces to different locations. Of course, if you create more than one source directory, you will need make more than one call to Link.Create or Link.Import in order to re-create the workspace in order to run your code.","title":"Workspaces containing Namespaces"},{"location":"Usage/WStoLink/#flat-workspaces-and-the-flatten-switch","text":"If your workspace is not divided into namespaces, but all your code and data are in the root (or #) namespace, it probably still consists of more than logically distinct sets of code (\"modules\"), that you might wish to manage separately. If you Export such a workspace, all the source files will obviously end up in the same folder. If you subsequently separate the source files into separate folders in order to make the source more manageable, you can still load it all into a single \"flat\" namespace using the -flatten switch. This allows the code to run unchanged, although you have created a structure for the source. The mappings to source files will be recorded, so that synchronisation will work if you edit the code in the APL system or using an external editor. If you create a new name inside the workspace, Link will obviously not know which folder to write it to, and will prompt you to specify a target folder.","title":"Flat Workspaces and the -flatten Switch"},{"location":"Usage/WStoLink/#recreating-the-workspace","text":"In order to recreate the workspace from source, you will need to make one or more calls to Link.Create or Link.Import , depending on the structure that you have created. For some ideas on how to set this up, see Setting up your Environment .","title":"Recreating the Workspace"}]}