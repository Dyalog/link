:Namespace FileSystemWatcher

    (⎕IO ⎕ML)←1 1

    USE_NQ←0                                ⍝ Set to 1 to enqueue calls to Notify via a Timer objecy
    FSWQ←'⎕SE.Link.FileSystemWatcher.QUEUE' ⍝ FSW Queue Object name prefix
    DEBUG←1                                 ⍝ Log events

    TimerEvent←140
    NotifyEvent←7777
    CloseEvent←7778
    Timeout←5000       ⍝ Length of timeout waiting for WatcherThread actions

    ∇ RequeuedEvent args
     ⍝ Process events redirected via the timer
     
      :Select 2⊃args
      :Case TimerEvent  ⍝ Timer; do nothing for now
      :Case NotifyEvent ⍝ Re-queued Notify event
          ⎕SE.Link.Notify 3⊃args
      :Case CloseEvent  ⍝ We have been asked to go away
          ⎕EX 1⊃args    ⍝ Erase the QUEUE object; WatcherThread will exit from DQ and the :Disposable control structure
      :EndSelect
    ∇

    ∇ WatchEvent(obj args);ct;info;nargs;timers
     ⍝ Callback for System.IO.FileSystemWatcher instance
     ⍝ Passes info on to ⎕SE.Link.Notify for processing
     
      {}2501⌶0 ⍝ Reap the thread on exit - triggers mantis 17628
      ⍝{}2502⌶0  ⍝ Discard parked thread - workaround mantis 17628
     
      nargs←⊂##.U.LCase⍕args.ChangeType
      nargs,←⊂args.FullPath
      :If 0≠⎕NC⊂'args.OldFullPath'
          nargs,←⊂args.OldFullPath
      :EndIf
     
      :If DEBUG≠0
          info←¯1↓{((3↑¨⍵)∊⊂'⎕SE')/⍵}{1↓¨(⍵=⎕UCS 13)⊂⍵}88⌶')SI'
          EVENTLOG[EVENTPTR+1]←⊂(3⊃⎕AI)nargs info
          EVENTPTR←(≢EVENTLOG)|EVENTPTR+1
      :EndIf
     
      :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
         ⍝ Do not split the following line into several lines: thread switch must NOT happen
          :If 0≠≢timers←'Timer'⎕WN ⎕SE.Link.FileSystemWatcher ⋄ ⎕NQ(⊃timers)NotifyEvent nargs ⋄ :EndIf
      :Else      ⍝ Make direct calls to Notify
          ⎕SE.Link.Notify nargs
      :EndIf
    ∇

    ∇ r←Watch args;tid;q;z;end
    ⍝ Set up a file system watcher, return object that will be stored as "fsw" in Link.Links[i]
     
      :If DEBUG≠0
          EVENTPTR←0
          EVENTLOG←100⍴⊂0 '' ''
      :EndIf
     
      :If USE_NQ ⍝ enqueue Notify work for later: Return NS containing QUEUE name and TID of ⎕DQ'ing thread
          z←{0::0 ⋄ 2503⌶⍵}2 ⍝ Children of this thread should not take interrupts
          q←FSWQ,⍕tid←WatcherThread&args
          z←{0::0 ⋄ 2503⌶⍵}z ⍝ Restore thread interruption setting
          end←Timeout+3⊃⎕AI
          :While 0=⎕NC q     ⍝ Wait for thread to create the Timer object
              :If end<3⊃⎕AI
                  'WatcherThread did not create Timer object'⎕SIGNAL 11
              :EndIf
              ⎕DL 0.05
          :EndWhile
          (r←⎕NS'').(QUEUE TID)←q tid ⍝ Return name of QUEUE object and TID ⎕NQ'ing it
     
      :Else ⍝ Make direct calls to Notify: return the FSW object
          r←MakeWatcher args
          r.EnableRaisingEvents←1
      :EndIf
    ∇

    ∇ Break link;timer;tid;end
    ⍝ Cleanly shut down a file system watcher
    ⍝ TODO : should break all at once : (EnableRaisingEvents←0) (⎕DL) (Dispose)
    ⍝   Called on Links[i].fsw by ⎕SE.Link.Break
      :If 0≠link.⎕NC'fsw'
      :AndIf ~0∊⍴link.fsw
          :If 2=⎕NC'link.fsw.QUEUE' ⍝ Did we using indirection via a queue?
              (timer tid)←link.fsw.(QUEUE TID)
              :If tid∊⎕TNUMS
              :AndIf 9=⎕NC timer
                  ⎕NQ timer CloseEvent ⍝ Tell it to go away
                  end←Timeout+3⊃⎕AI
                  :While tid∊⎕TNUMS     ⍝ Wait for thread to create the Timer object
                      :If end<3⊃⎕AI
                          ('WatcherThread ',(⍕tid),' did not die on request')⎕SIGNAL 11
                      :EndIf
                      ⎕DL 0.05
                  :EndWhile
              :EndIf
              ⎕EX link.fsw.QUEUE
          :Else ⍝ fsw should be a real FSW object
              :If 0≠⎕NC⊂'link.fsw.Dispose'
                  link.fsw.EnableRaisingEvents←0
                  ⎕DL 0.1 ⍝ Give any extant events time to be processed
                  link.fsw.Dispose
              :EndIf
          :EndIf
          link.fsw←⍬
      :EndIf
    ∇

    ∇ watcher←MakeWatcher args;⎕USING
     ⍝ Return a FileSystemWatcher object
     ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
      ⎕USING←',System',(~##.U.DotNetCore)/'.dll'
      watcher←⎕NEW System.IO.FileSystemWatcher
      watcher.(Path Filter)←args
      watcher.(onChanged onCreated onDeleted onRenamed)←⊂'WatchEvent'
      watcher.IncludeSubdirectories←1
    ∇

    ∇ WatcherThread args;q
     ⍝ Run a thread which creates a FileSystemWatcher object
     ⍝ ... makes sure there is a ⎕DQ to allow processing of events
     ⍝ ... and ensures it is disposed of
     
      :Disposable watcher←MakeWatcher args
          (q←FSWQ,⍕⎕TID)⎕WC'Timer'('Event'(TimerEvent NotifyEvent CloseEvent)'RequeuedEvent')('Interval' 1000)('Data'watcher)
          ⍝ 'Data' for testing purposes.
          watcher.EnableRaisingEvents←1
          ⎕DQ q ⍝ Wait here; q will be ⎕EX'd by Link.Break
          watcher.EnableRaisingEvents←0
          ⎕DL 1 ⍝ Wait for events to stop
      :EndDisposable
    ∇

    ∇ r←EventLog limit;log
     
      log←⌽EVENTPTR⌽EVENTLOG
      :If 0=≢log←↑(0≠¨⊃¨log)/log
          r←'Log is empty' ⋄ →0
      :EndIf
      log[;1]←log[1;1]-log[;1] ⍝ How long ago
      r←⊖log
    ∇

:EndNamespace
