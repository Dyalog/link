:Namespace U ⍝ Utilities

    :Section Constants
    isWindows←'Win'≡3↑⊃# ⎕WG'APLVersion'
    ∇ d←debug
      :If 0=⎕NC'##.DEBUG'
          d←##.DEBUG←0
      :Else
          d←##.DEBUG
      :EndIf
    ∇
    :EndSection


    :Section APL covers
      OnEach←{ ⍝ ¨ without prototype call on empty
          0∊⍴⍵:⍵   ⍝ if empty return empty
          ⍺←⊢      ⍝ ambivalent
          1:_←⍺ ⍺⍺¨⍵   ⍝ shy call
      }
    :EndSection


    :Section Stack Frames      ⍝ Tacit necessary to avoid them
    Resignal←⎕SIGNAL{⍺←'' ⋄ ⍵/⊂⎕DMX.(('EN'(EN+11×EN=0))('Message'(Message,⍺)))}
    Check←{⍺←0⋄⍺}⍴⍨¯1∊∘⎕NC⊢⊆⍨'/'≠⊢ ⍝ leave early if any bad name
    If←⍴⍨
    :EndSection



    :Section Strings
    Shortest←{⍵⊃⍨{⍵⍳⌊/⍵}≢¨⍵}                ⍝ Shortest string in list
    Case←{⍺(819⌶)¨⍵}                        ⍝ Upper/Lower case
    LCase←{819⌶⍵}                           ⍝ Lower case
    Join←{(⍕⍺),⍺⍺,(⍕⍵)}                     ⍝ Join using ⍺⍺
    Slash←{⍵∊'/\'}                          ⍝ Mark slashes
    Parts←{⍵⊆⍨~Slash ⍵}                     ⍝ Path parts
    Path←{⍵↓⍨-'/'⍳⍨⌽⍵}                      ⍝ Until last slash
    PadThis←{⍵,'⎕THIS'/⍨0=≢⍵}               ⍝ Default path to here
    NsExpr←{'''',⍵,'''⎕NS⍬'}                ⍝ Expression to create namespace
    Begins←{⊃⍺⍷⍵}                           ⍝ ⍵ starts with ⍺
    WinSlash←'\'@Slash⍣isWindows            ⍝ force windows slashes only on windows machines
    DotSlash←'.'@Slash                      ⍝ Convert dots to slashes
    Nss←{,\'.',¨1↓U.Parts ⍵}                ⍝ Convert file path to ns path
        Combine←{(⍕⍺),⍨(326≠⎕DR ⍺)/'.',⍨⍕⍵}/
    IsChild←(⍕¨# ⎕SE ⎕DMX)∘{~⍺∊⍨⊂,⍕⍵}
    List←{∊{' ',⍕⍵}¨⍵}
      Arrow←{                               ⍝ appropriate symbol to show ns-dir connection
          lr←'←→'/⍨2 2⊤'ns' 'dir' 'both'⍳⊂⍵.watch
          ⍵.ns,' ',lr,' ',WinSlash ⍵.dir
      }
    :EndSection



    :Section Covers for I-beams and other built-ins
    GetLinkInfo←{⍺.(5179⌶)⍵}         ⍝ Return link info
    CurrentFileName←{4⊃⍺.(5179⌶)⍵}   ⍝ Return current file name
    Where←{⍵⌿⍺}                      ⍝ Filter as function
    Norm←{∊1⎕NPARTS ⍵}
    GetFileInfo←{5174⌶⍵}             ⍝ Return links to file
      GetFile←{
          11::⊃⎕NGET ⍵ 1                     ⍝ 17.0 Unicode
          ⊃⎕NGET⍠'ContentType' 'APLCode'⊢⍵ 1 ⍝ 17.1+ Classic
      }
      QFixIfExists←{
          ⎕NEXISTS⊃⍵:_←⍺ ##.QFix ⍵
          1:_←⍬
      }
      GetInfos←{
          ''≡0⍴⍵:∇'name' 'parent' 'nc' 'file' 'line' 'lines' 'hash' 'ts'⍳⊂⍵
          ⍵∘⊃¨5177⌶⍬
      }

    ∇ (canwatch dotnetcore)←CanWatch dummy;⎕USING
      :Trap 0
        ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
          dotnetcore←(~##.U.isWindows)∨(,'1')≡2 ⎕NQ'.' 'GetEnvironment' 'DYALOG_NETCORE'
          ⎕USING←',System',(~dotnetcore)/'.dll'
          canwatch←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
      :Else
          canwatch←dotnetcore←0
      :EndTrap
    ∇

    ∇ r←RemoveFileLinksIn rootns;all;allrefs;urefs;mask;t;remove
     ⍝ Find all file system links to objects below rootns, and remove using 5178⌶
     ⍝ Return number of links broken
     
      allrefs←2⊃¨all←5177⌶⍬
      t←urefs←∪allrefs
      mask←(≢urefs)⍴0
     
      :If 0≠≢t
          :Repeat
              mask∨←t∊rootns ⍝ Have we reached rootns?
              t←t.##         ⍝ Move all pointers up to parent
          :Until t≡t.##      ⍝ Continue until everything is "root"
      :EndIf
     
      :If 0≠r←≢remove←(allrefs∊mask/urefs)/all ⍝ links to be removed
          r←+/5178⌶¨(⍕¨2⊃¨remove),¨'.',¨⍕¨1⊃¨remove
      :EndIf
    ∇
    :EndSection



    :Section Files
    ∇ dir←trail NormDir dir
      dir←∊1 ⎕NPARTS dir                 ⍝ normalise - '' means current dir
      :If trail ⋄ dir,←'/'/⍨~'/\'∊⍨⊃⌽dir ⍝ append trailing slash if missing
      :Else ⋄ dir↓⍨←-+/∧\⌽dir∊'/\'       ⍝ remove trailing slash
      :EndIf
      dir←WinSlash dir                 ⍝ use windows slash on windows machines
    ∇
    Ancestry←{((¯1+⍵⍳'/')↑⍵)∘,¨,\('/'=⍵)⊂⍵}

    FileHash←{2 ⎕NQ #'GetBuildID' ⍵}

      IsDir←{
          22::0
          1=1 ⎕NINFO ⍵
      }

      Into←{ ⍝ Put vtv into file
          22::⍵                  ⍝ no file access
          _←3 ⎕MKDIR⊃1 ⎕NPARTS ⍵ ⍝ create dir if needed
          0⊣(⊂⍺)⎕NPUT ⍵ 1        ⍝ overwrite
      }

      ApplyOldExtn←{ ⍝ Correct new extension to .dyalog if old source exists
          (dir name ext)←⎕NPARTS ⍵
          ext≡'.dyalog':⍵
          alt←dir,name,'.dyalog'
          (⎕NEXISTS alt):alt
          ⍵
      }

    :EndSection



    :Section Lookup
    ∇ (container text)←rsi_xsi ContainerNs ns;n;NormNs;rsi;xsi
      (rsi xsi)←rsi_xsi
      NormNs←{ns←,⍕⍵ ⋄ 9∊⎕NC ns:⍕⍎ns ⋄ ns}
      :If 9=⎕NC'ns'
          (container text)←#(⍕ns)
      :ElseIf '#⎕'∊⍨⊃ns
          (container text)←#(NormNs ns⊣' *** Invalid target'Resignal{(¯1∊⎕NC'⍵')∧ns≢,'#'}ns)
      :Else
          n←xsi{(⍵∊⍺)×¯1+⍺⍳⍵}⊂'⎕SE.UCMD' ⍝ Drop UCMD stack if present
          container←⊃n↓rsi
              text←NormNs(⍕container),(0≠≢ns)/'.',ns
      :EndIf
    ∇

      Tail←{ ⍝ ⍺:opts; ⍵:nc
          0=⍵:'/'
          (types exts)←↓⍉⍺.typeExtensions
          exts,←⊂'dyalog'
          exts,¨⍨←'.'
          exts⊃⍨⌊/types⍳⍵,⌊⍵
      }
    ∇ r←GetName file;code;ns
    ⍝ Attempt to determine the name which will be defined by a file
      ns←(⎕NS'').⎕NS r←'' ⍝ Two levels of nesting to allow safe fixing of :Namespace/##.⎕IO←0/:EndNamespace
      :Trap 0
          2 ns.⎕FIX'file://',file
          :If 1=≢r←ns.⎕NL-⍳10 ⋄ r←⊃r
          :Else ⋄ r←''
          :EndIf
      :EndTrap
    ∇
    ∇ r←GetRefTo nsname;name;nc
     ⍝ Get a reference to a container namespace (or ⍬ if that is not possible)
      nc←⎕NC⊂nsname
      :If 9=⌊nc      ⍝ if it is already there
      :OrIf ~IsChild nsname ⍝ or a root
          r←⍎nsname
      :ElseIf ¯1=nc ⍝ Not a valid name, not worth trying
          r←⍬
      :Else
          :Trap 0
              :For name :In (¯1+⍸'.'=nsname,'.')↑¨nsname ⍝ growing paths
                  :If 9.1≠nc ⍝ Not a namespace
                      name ⎕NS''
                  :EndIf
              :EndFor
          :Else
              r←⍬
          :EndTrap
      :EndIf
    ∇
    :EndSection


    :Section Link Private function    ⍝ to avoid clobber auto-complete in ⎕SE.Link
    ∇ (file oldfile)←fix DetermineFileName(opts ns name oldname src);dir;ext;nc;oldfile;userfile;where
    ⍝ what should the file name be according to link
      oldfile←ns CurrentFileName name         ⍝ Grab file info before ⎕FIX might destroy it
      file←(oldname≡name)/oldfile  ⍝ if object was renamed we don't have a file name any more
      :If 0=nc←ns.⎕NC⊂,name
      :AndIf 0≠≢src
          :If fix ⋄ where←ns    ⍝ fix in actual namespace
          :Else ⋄ where←⎕NS ⍬   ⍝ fix in toy namespace
          :EndIf
          :Trap 0 ⋄ 2 where.⎕FIX src
          :Else ⋄ U.Resignal 1
          :EndTrap
          nc←where.⎕NC⊂,name  ⍝ infer nameclass from source
      :EndIf
      :If 0=≢file  ⍝ no existing file name for it
          :If ~opts.flatten
              file←(≢opts.ns)↓⍕ns              ⍝ Add sub.namespace structure
              ((file='.')/file)←'/'            ⍝ Convert dots to /
          :EndIf
          file←opts.dir,file               ⍝ Add link directory
          file,←'/',name                   ⍝ Add object name
          file,←opts Tail nc             ⍝ Add extension
      :EndIf
      ⍝ Allow user to determine file name - they return '' to give up
      :If 3=(⍎opts.ns).⎕NC opts.beforeWrite
      :AndIf 0<≢userfile←(opts.ns⍎opts.beforeWrite)ns name oldname nc src file opts 1
          file←userfile
      :EndIf
      ⍝ enforce file extension / file names
      (dir file ext)←⎕NPARTS file
      :If opts.forceExtensions∨0=≢ext
      :OrIf ~⎕NEXISTS file
          ext←opts Tail nc
      :EndIf
      :If opts.forceFilenames ⋄ file←name ⋄ :EndIf
      file←dir,file,ext
      file←ApplyOldExtn⍣(~opts.forceExtensions)⊢file
      file←##.CaseCode⍣opts.caseCode⊢file ⍝ case code?
    ∇
    :EndSection

:EndNamespace
