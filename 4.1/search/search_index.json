{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Link allows you to use Unicode text files to store APL source code, rather than \"traditional\" binary workspaces. The benefits of using Link and text files include:</p> <ul> <li> <p>It is easy to use source code management (SCM) tools like Git or Subversion to manage your code. Although an SCM is not a requirement for Link, Dyalog highly recommends using Git or similar systems to manage source code that Link will load into your APL session.</p> </li> <li> <p>Changes to your code are immediately written to file: there is no need to remember to save your work. The assumption is that you will make the record permanent with a commit to your source code management system, when the time is right.</p> </li> <li> <p>Unlike binary workspaces, text source can usually be shared between different versions of APL - or even with human readers or writers who don't have APL installed at all.</p> </li> </ul>"},{"location":"#link-is-not","title":"Link is NOT...","text":"<ul> <li>A source code management system: Link itself has no source code management features. As mentioned above, you will need to use a separate tool like Git to manage the source files that Link will allow you to use and modify from Dyalog APL.</li> <li>A database management system: although Link is able to store APL arrays using array notation, this is only intended to be used for constants which you consider to be part of the source code of your applications. Although all functions and operators that you define using the editor will be written to source files by default, source files are only created for arrays by explicit calls to Link.Add or by specifying optional parameters to Link.Export. Application data should be stored in a database management system or files managed by the application.</li> </ul>"},{"location":"#link-fundamentals","title":"Link fundamentals","text":"<p>Link establishes links between one or more namespaces in the active APL workspace and corresponding directories containing APL source code in Unicode test files. For example, the following user command invocation will link a namespace called <code>myapp</code> to the folder <code>/home/sally/myapp</code>:</p> <pre><code>      ]LINK.Create myapp /home/sally/myapp\n</code></pre> <p>A set of API functions is available in the session namespace <code>\u2395SE</code>, for performing Link operations under programme control. Using the API, the above would be written:</p> <pre><code>      \u2395SE.Link.Create 'myapp' '/home/sally/myapp'\n</code></pre> <p>If <code>myapp</code> contains sub-directories, a namespace hierarchy corresponding to the directory structure will be created within the <code>myapp</code> namespace. By default, the link is bi-directional, which means that Link will:</p> <ul> <li>Keep source files up-to-date:  Any changes made to code in the active workspace using the tracer and editor are immediately replicated in the corresponding text files.</li> <li>Keep the workspace up-to-date: If .NET is available, then any changes made to the external files using a text editor, or resulting from an SCM action such as rolling back or switching to a different branch, will immediately be reflected in the active workspace.</li> </ul> <p>Note</p> <p>For Dyalog to automatically update workspace contents due to file changes requires .NET.</p> <p>The .NET Framework is included with Microsoft windows. For other platforms  or more recent versions of .NET, .NET can be downloaded from  dotnet.microsoft.com/download.</p> <p>To find out which versions are supported, see section 2.1 of the .NET Interface Guide and under the heading \"Prerequisites\" in chapter 1 of the Dyalog for Microsoft Windows .NET Framework Interface Guide.</p> <p>You can invoke Link.Create several times to create multiple links, and you can also use Link.Import or Link.Export to import source code into the workspace or export code to external files without creating links that will respond to subsequent changes. </p>"},{"location":"#functions-vs-user-commands","title":"Functions vs. User Commands","text":"<p>With a few exceptions, each Link API function has a corresponding User Command, designed to make the functionality slightly easier to use interactively in the session.</p>"},{"location":"#user-commands","title":"User commands","text":"<p>The user commands have the general syntax</p> <pre><code>     ]LINK.CmdName arg1 [arg2] [-name[=value] ...]\n</code></pre> <p>where <code>arg2</code>'s presence depends on the specific command, <code>-name</code> is a flag enabling the specific option and <code>-name=value</code> sets that option to a specific value. Some options (like <code>codeExtensions</code> and <code>typeExtensions</code>) require an array of values: in these cases the user commands typically take the name of a variable containing that array.</p> <p>For a list of installed user commands, type:</p> <pre><code>     ]LINK -?\n</code></pre>"},{"location":"#api-functions","title":"API functions","text":"<p>The API is designed for use under program control, and options are provided in an optional namespace passed as the left argument. The general syntax of the utility functions is</p> <pre><code>     options FnName arguments\n</code></pre> <p>where <code>options</code> is a namespace with variables, named according to the option they set, containing their corresponding values. The <code>-name=value</code> option can be set by <code>options.name\u2190value</code>, and switches with values (e.g. <code>-name</code>) can be set by <code>options.name\u21901</code>. Unset options will assume their default value.</p> <p>Options can also be provided as a character vector with the literal array representation of the option workspace, for example:</p> <pre><code>     '(name: 1)' FnName arguments\n</code></pre> <p>The details of the arguments and options can be found in the API Reference.</p>"},{"location":"#further-reading","title":"Further reading","text":"<p>To get started using Link, please read:</p> <ul> <li>Basic Usage to see how to set up your first links, and learn about exporting existing application code to source files.</li> <li>Setting Up Your Environment for a discussion of how to set up Link-based development and runtime environments.</li> <li>Technical Details and Limitations if you want to know about the full range of APL objects that are supported, and some of the edge cases that are not yet supported by Link.</li> </ul> <p>If you have an existing APL application that you want to move to Link, you might want to read one of the following texts first:</p> <ul> <li>Converting Your Workspace to Text Source: if you already have an existing body of APL code in binary workspaces.</li> <li>Migrating to Link 3.0 from SALT: if you are already managing text source using Link's predecessor SALT.</li> </ul>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What happens if I save a workspace after creating Links?</li> <li>Are workspaces dead now?</li> <li>How is Link implemented?</li> </ul>"},{"location":"ReleaseNotes41/","title":"Version 4.1 Release Notes","text":"<p>Link version 4.1 is distributed with Dyalog APL version 20.0 and is supported with version 19.0. You can select documentation for other versions of Link using the dropdown in the title bar.</p> <p>Apart from these release notes and minor corrections to the documentation, the documentation for version 4.1 is identical to 4.0. Version 4.1 is primarily a bug fix release. A couple of significant groups of fixes are discussed below, and the version 4.1 milestone on GitHub documents the full set of issues that are resolved by version 4.1.</p>"},{"location":"ReleaseNotes41/#control-reformatting","title":"Control Reformatting","text":"<p>In addition to fixes, Link 4.1 recognises a new environment setting <code>ALWAYSREFORMAT</code>, which turns on automatic reformatting of all source code as it is written to source files. The following values are accepted:</p> <ul> <li>ALWAYSREFORMAT=0: Do not reformat the source code</li> <li>ALWAYSREFORMAT=1: Reformat using standard tab settings (4), as returned by (<code>61 \u2395ATX</code>)</li> <li>ALWAYSREFORMAT=2: Use user-configured tab settings, as returned by <code>\u2395CR</code> or <code>\u2395NR</code>.</li> </ul>"},{"location":"ReleaseNotes41/#linkcreate-ignores-local-names","title":"Link.Create ignores local names","text":"<p><code>Link.Create</code> ignores calling functions and names localised by such functions when determining whether the target namespace is empty.  This makes it much possible to a write a startup function that creates a link to the root namespace (<code>#</code>) when an application starts.</p> <p>Ealier versions of Link would complain that the target namespace is not empty.</p>"},{"location":"ReleaseNotes41/#linkcreate-preloaded-allows-optimised-development-environments","title":"Link.Create -preloaded Allows Optimised Development Environments","text":"<p>If an application uses thousands (or tens of thousands) of source files, <code>Link.Create</code> can take a a significant amount of time. The <code>-preloaded</code> switch allows you to build a development workspace using <code>Link.Create</code>, and save this workspace or export the contents to a shared code file. At the start of a development session, you can call <code>Link.Create</code> with the <code>-preloaded</code> switch, which will re-establish all metadata related to the link, but skip loading the source code.</p>"},{"location":"ReleaseNotes41/#significant-fixes","title":"Significant fixes","text":""},{"location":"ReleaseNotes41/#improved-error-messages","title":"Improved Error Messages","text":"<p>Several error messages have been improved. For example, when a file cannot be imported to a classic interpreter due to a TRANSLATION ERROR, the file and the offending character is identified.</p>"},{"location":"ReleaseNotes41/#improved-file-system-watcher","title":"Improved File System Watcher","text":"<p>The most significant improvement in version 4.1 is a complete rewrite of the code  that handles file system watcher events, which increased the performance and the robustness of Link, when faced with several more or less simultaneous file updates.</p> <p>For example, when using a source code management system like Git, a branch switch or a revert operation may cause a flurry of change to files. In Link 4.0, this could sometimes lead to functions disappearing, or failing to disappear when they should, as a result of processing messages in the wrong order.</p> <p>Although Link 4.1 is very much more robust than Link 4.0 in this regard, it is still not recommended to copy or unzip hundreds or thousands of files with an active file system watcher.</p>"},{"location":"API/","title":"API Overview","text":""},{"location":"API/#api-function-syntax","title":"API function syntax","text":"<p>The Link API functions all reside in <code>\u2395SE.Link</code>.</p> <p>The general syntax for Link API functions is as follows: <pre><code>      message \u2190 options \u2395SE.Link.FnName args\n</code></pre> where:</p> <ul> <li><code>message</code> is a simple character vector or nested array containing messages related to the effects of the function call.</li> <li><code>options</code> is a namespace containing optional parameters. Only certain functions accept an options namespace.</li> <li><code>FnName</code> is the name of the API function</li> <li><code>args</code> is either a character vector or a nested vector as described in the help section for that API function.</li> </ul>"},{"location":"API/#option-namespaces","title":"Option Namespaces","text":"<p>Some API functions accept an option namespace as the left argument. For example, to create a link with non-default <code>source</code> and <code>flatten</code> options, you would write:</p> <pre><code>      options\u2190\u2395NS \u236c                                     \u235d create empty namespace\n      options.(source flatten)\u2190'dir' 1                  \u235d set two named options\n      options \u2395SE.Link.Create 'myapp' '/sources/myapp'  \u235d namespace and director name on the right, options on left\n</code></pre> <p>Creating option namespaces will become more elegant once Dyalog APL is enhanced with a notation for namespaces. Until that time (no definite schedule has yet been set), Link API functions will accept a character vector left argument which represents an array in the proposed Literal Array Notation, for example: <pre><code>        '(source:''dir'' \u22c4 flatten:1)' \u2395SE.Link.Create 'myapp' '/sources/myapp' \n</code></pre></p>"},{"location":"API/#user-commands","title":"User commands","text":"<p>Most API functions have a corresponding user command, to make them a little easier to use interactively. The API functions with user command covers are indicated with <sup><code>]</code></sup> in the function reference tables. These user commands all take exactly the same arguments and options as the API functions, specified using user command syntax. The Link.Create call above would thus be written: <pre><code>      ]LINK.Create myapp /sources/myapp -source=dir -flatten\n</code></pre></p> <p>Lowercase option names: Although option names are case sensitive and some of them contain uppercase letters when provided to API functions via option namespaces, the user command option names are entirely lowercase, to make interactive use more convenient.</p> <p>Specifying extensions: Two options require arrays identifying file extensions: <code>codeExtensions</code>, <code>customExtensions</code> and <code>typeExtensions</code>. For convenience, the <code>]LINK.Create</code> user command accepts the name of a variable containing the array, rather than the array values. </p> <p>A list of available user commands can be viewed in the session with <code>]LINK -?</code>. Help for a particular user command <code>Cmd</code> is displayed using <code>]LINK.Cmd -?</code>.</p>"},{"location":"API/#basic-api-function-reference","title":"Basic API Function reference","text":"<p>The following functions cover the vast majority of normal use-cases:</p> Function User Command Right Argument(s) Left Argument(s) Result Add <code>]Add</code> items message Break <code>]Break</code> namespaces options: <code>all</code> <code>recursive</code> message Configure <code>]Configure</code> target settings current or previous settings Create <code>]Create</code> namespace directory options: <code>source</code> <code>watch</code> <code>arrays</code> (and many more) message Export <code>]Export</code> namespace directory options: <code>overwrite</code> <code>caseCode</code> <code>arrays</code> <code>sysVars</code> message Expunge <code>]Expunge</code> items boolean array Import <code>]Import</code> namespace directory options: <code>overwrite</code> <code>flatten</code> <code>fastLoad</code> message LaunchDir none none directory name Refresh <code>]Refresh</code> namespace options: <code>source</code> message Resync <code>]Resync</code> namespace options: <code>proceed</code> <code>arrays</code> <code>sysvars</code> message Status <code>]Status</code> namespace options: <code>extended</code> message Version version number as string <p>Note</p> <p>The currently active version of Link is reported by <code>\u2395SE.Link.Version</code> and found in the output of <code>]TOOLS.Version</code></p>"},{"location":"API/#advanced-api-function-reference","title":"Advanced API Function reference","text":"<p>The \"advanced\" functions are typically used when building your own tools on top of Link, rather than simply using Link to maintain the source of an application:</p> Function User Command Right Argument(s) Left Argument(s) Result CaseCode filename &lt;none&gt; case-coded filename Fix source array: namespace name oldname boolean GetFileName <code>]GetFileName</code> items &lt;none&gt; filenames GetItemName <code>]GetItemName</code> filenames &lt;none&gt; items Notify event filename oldfilename &lt;none&gt; &lt;none&gt; StripCaseCode filename &lt;none&gt; filename without case code TypeExtension name class option namespace used for Create file extension (without leading <code>'.'</code>)"},{"location":"API/Link.Add/","title":"Link.Add","text":""},{"location":"API/Link.Add/#syntax","title":"Syntax","text":"<pre><code>]LINK.Add name\u2190expression\n\nmessage \u2190 \u2395SE.Link.Add name\u2190expression \n</code></pre> <p>Show User Command information in the session with <code>]LINK.Add -?</code></p> <p>This function allows you to add one or more APL items to the link, creating the appropriate representation in the linked directory. New in 4.0 is that you can evaluate an expression and assign the result into the items before <code>]LINK.Add</code> is run. Note that a source file will only be created or updated if the item is in a linked namespace.</p> <p>This is useful to write a new or modified array to a source file: arrays are normally not written to file by Link.</p> <p>It is also useful when a change has been made to a linked item using any mechanism other than the APL editor, for example the definition of a new dfn using assignment, or the use of <code>)COPY</code> to bring new objects into the workspace.</p> <p>Note</p> <p>You can create or update an item from source while adding it to the Link by calling Link.Fix.</p>"},{"location":"API/Link.Add/#arguments","title":"Arguments","text":"<ul> <li><code>name</code> is a simple character vector or nested vector of character vectors containing the names of items to be added to the link.     In the user command, <code>&lt;name&gt;</code> is a space-separated list of names.</li> <li><code>expression</code> is an expression that is evaluated and assigned to the single or list of items before <code>]LINK.ADD</code> takes affect. That is, that the expression is not saved, but the result of it is. </li> </ul>"},{"location":"API/Link.Add/#result","title":"Result","text":"<ul> <li><code>message</code> is a simple character vector describing items that were:</li> <li>Added (they belong in a linked namespace and were successfully added)</li> <li>Not linked (they do not belong to a linked namespace)</li> <li>Not found (the name doesn't exist at all)</li> </ul>"},{"location":"API/Link.Break/","title":"Link.Break","text":"<pre><code>]LINK.Break [&lt;ns&gt;] [-all={#|\u2395SE|*}] [-recursive={on|off|error}]\n\nmessage \u2190 {options} \u2395SE.Link.Break namespace\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Break -?</code></p> <p>Breaks an existing link: Does not affect the contents of the active workspace except to remove all traces of the link, preventing any further synchronisation from taking place.</p> <p>Note</p> <p>If you have enabled Pause Threads on Error and you have an application thread running which encounters an error, Link.Break can hang when the thread which is created to shut down the file system watcher becomes paused. If this happens, use IDE menu items to resume execution.</p>"},{"location":"API/Link.Break/#arguments","title":"Arguments","text":"<p><code>namespace</code> is a list of namespace names as character vectors or references</p> <p>In the user command, <code>&lt;ns&gt;</code> is a space-separated list of namespace names</p>"},{"location":"API/Link.Break/#options","title":"Options","text":""},{"location":"API/Link.Break/#all","title":"all","text":"<p>{#<code>|\u2395SE|*</code>}</p> <p>By default (<code>-all</code> or <code>-all=#</code>), break links to all namespaces within the main workspace. </p> <p>To break links to namespaces in the session space, use <code>-all=\u2395SE</code>, and to break absolutely all links, <code>-all=*</code>.</p> <p>Note that the list of namespaces is ignored when <code>-all</code> is used.</p>"},{"location":"API/Link.Break/#recursive","title":"recursive","text":"<p>{on|off|error}</p> <p>Break child namespaces too if they have separately defined links.</p>"},{"location":"API/Link.Break/#result","title":"Result","text":"<p><code>message</code> is a simple character vector describing namespaces that were: - effectively unlinked - not linked in the first place - not found</p>"},{"location":"API/Link.CaseCode/","title":"Link.CaseCode","text":"<pre><code>names \u2190 {options} \u2395SE.Link.CaseCode filenames\n</code></pre> <p>The CaseCode function adds case coding to any file name. It is intended for use in functions which implement <code>getFilename</code> callbacks, which you can set up when you create a Link, to allow your code to generate file names. If case coding is enabled for the repository, the file name should be correctly case coded. For example, if <code>/tmp</code> is a currently linked folder:</p> <pre><code>      \u2395SE.Link.CaseCode 'c:\\tmp\\HelloWorld.apln' 'c:\\tmp\\FOO.aplf'\n c:/tmp/HelloWorld-41.apln  c:/tmp/FOO-7.aplf \n</code></pre>"},{"location":"API/Link.CaseCode/#what-is-a-case-code","title":"What is a \"case code\"?","text":"<p>A reverse binary indication of the letter cases in the main part of the name, encoded in octal. For example</p> <p><code>HelloWorld</code>\u2003has the uppercase indication <code>1000010000</code>\u2003which when reversed is <code>0000100001</code>\u2003which is binary for <code>\u00a0 \u00a0 \u00a0 \u00a0 33<sub>10</sub></code>\u2003which in octal is <code>\u00a0 \u00a0 \u00a0 \u00a0 41<sub>8</sub></code>\u2003so the full name including case code is <code>HelloWorld-41</code></p>"},{"location":"API/Link.CaseCode/#arguments","title":"Arguments","text":"<p><code>filenames</code> is a simple character vector or vector of character vectors containing file names which do not contain case codes. The file names do not need to exist, but they need to reference a currently linked folder.</p>"},{"location":"API/Link.CaseCode/#result","title":"Result","text":"<ul> <li>Case coded file name(s)</li> </ul>"},{"location":"API/Link.Configure/","title":"Link.Configure","text":""},{"location":"API/Link.Configure/#syntax","title":"Syntax","text":"<pre><code>]LINK.Configure &lt;target&gt; [settings]\n\nmessage \u2190 \u2395SE.Link.Configure target [settings]\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Configure -?</code></p>"},{"location":"API/Link.Configure/#arguments","title":"Arguments","text":"<ul> <li><code>target</code> can be <code>*</code> to refer to the user configuration. It can be a reference to, or a simple character vector containing the name of a namespace. Finally, it can be the full name of a configuration file. </li> <li><code>settings</code> is a list in the form <code>name:value</code>, providing new values for configuration settings. If no value is provided (there is nothing following the colon), the setting is deleted from the corresponding configuration file. </li> </ul>"},{"location":"API/Link.Configure/#result","title":"Result","text":"<ul> <li>If no <code>settings</code> were provided, Configure returns a formatted display of the current contents of the configuration file. Otherwise, it returns the previous values for any settings mentioned in the argument. </li> </ul>"},{"location":"API/Link.Create/","title":"Link.Create","text":""},{"location":"API/Link.Create/#syntax","title":"Syntax","text":"<pre><code>]LINK.Create [ns] &lt;dirorfile&gt; [-source={ns|dir|auto}] [-watch={none|ns|dir|both}] [-casecode] [-forceextensions] [-forcefilenames] [-arrays] [-sysvars] [-flatten] [-preloaded] [-beforeread=&lt;fn&gt;] [-beforewrite=&lt;fn&gt;] [-getfilename=&lt;fn&gt;] [-codeextensions=&lt;var&gt;] [-typeextensions=&lt;var&gt;] [-fastload] [-ignoreconfig] [-text={aplan|plain}]\n\nmessage \u2190 {options} \u2395SE.Link.Create (namespace directory)\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Create -?</code></p>"},{"location":"API/Link.Create/#arguments","title":"Arguments","text":"<ul> <li> <p><code>namespace</code> is optional; if it is not provided, <code>-source=dir</code> is implied and a link with the name of the directory being linked to will be created within the current namespace. If provided, it must be a reference to, or a simple character vector containing the name of a namespace.  </p> <p>Note that if a reference is used, it must refer to a namespace which has a display form which has name class 9 and can be used to locate the namespace. Links can not be created to \"anonymous\" spaces with names containing <code>[namespace]</code> or similar segments.</p> </li> <li> <p><code>dirorfile</code> is a simple character vector containing the path to a file system directory (without a trailing backslash), or a single text file defining a namespace, class or interface.</p> </li> </ul>"},{"location":"API/Link.Create/#result","title":"Result","text":"<ul> <li> <p><code>message</code> is a simple character vector describing the established link, along with possible failures</p> </li> <li> <p>If <code>namespace</code> is <code>#</code> and the current workspace is isn't associated with a file (<code>\u2395WSID\u2261'CLEAR WS'</code>) then <code>\u2395WSID</code> will be set to <code>directory</code>. The value will be with a trailing slash or backslash to prevent being mistaken for a file name. The default titlebar caption of RIDE and the Windows IDE can then be used to keep track of which session is linked to which directory and a custom titlebar captions can use the <code>{WSID}</code> tag to include the value.</p> </li> </ul>"},{"location":"API/Link.Create/#common-options","title":"Common options","text":""},{"location":"API/Link.Create/#source","title":"source","text":"<p>Default: auto</p> <p>The source option specifies whether to consider the namespace in the active workspace (ns) or directory on the file system (dir) as the source (also used by a subsequent Refresh).</p> <p><code>source</code> is a simple character vector, one of <code>'ns'</code>, <code>'dir'</code> or <code>'auto'</code>. From Link version 4.0, a file name can be used to load a namespace, class or interface from a single file, but <code>dir</code> is still used in this case.</p> <ul> <li>dir means that the namespace must be non-existent or empty and will be populated from source files.</li> <li>ns means that the directory must be non-existent or empty and will be populated by source files for the items in the namespace.</li> <li>auto will use whichever of ns or dir that is not empty. If both are empty, it will use dir on a subsequent Refresh.</li> </ul>"},{"location":"API/Link.Create/#watch","title":"watch","text":"<p>Default: both if a file system watcher can be created, else ns</p> <p>The watch option specifies which sides of the link to watch for changes (and synchronise). Watching a dir (or both) is currently only supported using the .NET Framework or .NET Core.</p> <p><code>watch</code> is a simple character vector, one of <code>'none'</code>, <code>'ns'</code>, <code>'dir'</code> or <code>'both'</code>.</p> <ul> <li>none: changes are not automatically propagated across the link in either direction.</li> <li>ns: changes made in a linked namespace changes (made with the editor) will be copied to files. Note that it will not reflect changes made using other mechanisms, such as assignment, <code>\u2395FX</code>, <code>\u2395FIX</code>, <code>\u2395CY</code>,  or <code>\u2395NS</code>. If you want to programmatically change an item so that the change is reflected to files, you should use \u2395SE.Link.Fix.</li> <li>dir will mirror changes made to files (using any mechanism) into the linked namespace. Note that there is a chance that updating a large number of files (e.g. git checkout, git pull or an unzip) may cause the file system watcher to miss changes and not report them to Link. If the source files are on a network drive, the file system watcher may be even more unreliable. Use \u2395SE.Link.Resync if you suspect something is wrong.</li> <li>both will synchronise changes in both directions. This is the default, and is recommended except in very special circumstances.</li> </ul> <p>Note</p> <p>Link.Refresh can be used to force a wholesale update of everything based on the setting of the <code>-source</code>option, and Link.Resync can always be used to generate a list of differences between the workspace and linked directories if you are in doubt about the current state.</p>"},{"location":"API/Link.Create/#arrays","title":"arrays","text":"<p>Default: off</p> <p>The arrays flag will export arrays on link creation.</p> <ul> <li>if simply set (<code>options.arrays\u21901</code> for the function or <code>-arrays</code> for the user command), then all arrays are exported.</li> <li>if set to a comma-separated list of names (<code>options.arrays\u2190'name1,name2,...'</code> for the function or <code>-arrays=name1,name2,...</code> for the user command) then arrays with specified names are exported.</li> </ul> <p>This option takes effect only when source is ns, and only when the link is initially created.</p>"},{"location":"API/Link.Create/#sysvars","title":"sysVars","text":"<p>Default: off</p> <p>The sysVars flag will export namespace-scoped system variables to file.</p> <p>The exhaustive list of exported variables is: <code>\u2395AVU  \u2395CT  \u2395DCT  \u2395DIV  \u2395FR  \u2395IO  \u2395ML  \u2395PP  \u2395RL  \u2395RTL  \u2395USING  \u2395WX</code>. They will be exported for all unscripted namespaces.</p> <p>This option takes effect only when source is ns.</p>"},{"location":"API/Link.Create/#forceextensions","title":"forceExtensions","text":"<p>Default: off</p> <p>The forceExtensions flag forces correct file extensions.</p> <p>If enabled, file extensions will be adjusted (if necessary), when an item is defined in the workspace from an external file, so that the file extension accurately reflects the type of the item according to typeExtensions.</p>"},{"location":"API/Link.Create/#forcefilenames","title":"forceFilenames","text":"<p>Default: off</p> <p>The forceFilenames flag will force correct file names.</p> <p>If enabled, file names will be adjusted so that they match the item name, when an item is defined in the workspace from an external file, so that the file name matches the name of the item.</p> <p>By default, Link will always create new files with the same name as items created in the active workspace. However, it will not insist that file names match item names when importing items from a directory.</p> <p>If forceFilenames is not set.  Link will update to the same file that an item was loaded from, even though the file name does not match the item name.</p>"},{"location":"API/Link.Create/#advanced-options","title":"Advanced Options","text":""},{"location":"API/Link.Create/#ignoreconfig","title":"ignoreconfig","text":"<p>Default: off</p> <p>The ignoreconfig allows you to ignore the <code>.linkconfig</code> file in the linked directory. This can be useful during debugging, especially if you have a damaged configuration file.</p>"},{"location":"API/Link.Create/#flatten","title":"flatten","text":"<p>Default: off</p> <p>The flatten flag prevents the creation of sub-namespaces in the active workspace.</p> <p>The flatten option will load all items into the root of the linked namespace, even if the source code is arranged into sub-directories. This is typically used for applications that have source which is divided into modules, but still expects to run in a \"flat\" workspace.</p> <p>Note that if flatten is set, newly created items need special treatment:</p> <ul> <li>If a function or operator is renamed in the editor, the new item will be placed in the same folder as the original item.</li> <li>If a new item is created, it will be placed in the root of the linked directory.</li> <li>It is also possible to use the getFilename setting to add application-specific logic to determine the file name to be used (or prompt the user for a decision).</li> </ul> <p>A suggested workflow is to always create a stub source file in the correct directory and edit the function that appears in the workspace, rather than creating new functions in the workspace.</p> <p>This option takes effect only when source is dir.</p>"},{"location":"API/Link.Create/#preloaded","title":"preloaded","text":"<p>Default: off</p> <p>The preloaded flag skips the reading of source files when creating links. This is useful if you have loaded a saved workspace which is known to contain the latest version of the source, or have materialised the source using other mechanisms such as shared code files.</p>"},{"location":"API/Link.Create/#casecode","title":"caseCode","text":"<p>Default: off</p> <p>The caseCode flag adds a suffix to file names on write.</p> <p>If your application contains items with names that differ only in case (for example <code>Debug</code> and <code>DEBUG</code>), and your file system is case-insensitive (for example, under Microsoft Windows), then enabling caseCode will cause a suffix to be added to file names, containing an octal encoding of the location of uppercase letters in the name.</p> <p>For example, with caseCode on, two functions named <code>Debug</code> and <code>DEBUG</code> will be written to files named <code>Debug-1.aplf</code> and <code>DEBUG-37.aplf</code>.</p> <p>Note</p> <p>Dyalog recommends that you avoid creating systems with names that differ only in case. This feature primarily exists to support the import of applications which already use such names. You will probably also want to enable forceFilenames if you enable caseCode.</p>"},{"location":"API/Link.Create/#beforewrite","title":"beforeWrite","text":"<p>If you specify a beforeWrite function, it will be called before Link updates a file or directory, allowing support of custom code or data formats. </p> <p><code>beforeWrite</code> is a simple character vector containing the name of a function relative to the linked namespace.</p> <p>In the user command, simply give the name. For example: <code>]LINK.Create -beforeWrite=Foo ns /tmp/folder</code></p> <p>Your function will be called with a nested right argument containing the following elements:</p> Index Description [1] Event name ('beforeWrite') [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to write to (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to write [5] Name class of the APL item to write [6] Old APL name (different from APL name if the write is due to a rename) [7] Source code that Link intends to write to file <p>Note</p> <p>Do not assume a specific length, more elements may be added in the future.</p> <p>Your callback function must return one of the following results:</p> <ul> <li><code>0</code>: The beforeWrite function has completed all necessary actions. Link should not update any files.</li> <li><code>1</code>: The beforeWrite function wishes to \"pass\" on this write: Link should proceed as planned.</li> </ul>"},{"location":"API/Link.Create/#beforeread","title":"beforeRead","text":"<p>If you specify a beforeRead function, it will be called before Link reads source from a file or directory, allowing support of custom code or data formats.</p> <p><code>beforeRead</code> is a simple character vector containing the name of a function relative to the linked namespace.</p> <p>In the user command, simply give the name. For example: <code>]LINK.Create -beforeRead=Foo ns /tmp/folder</code></p> <p>Your function will be called with a nested right argument containing the following elements:</p> Index Description [1] Event name (<code>'beforeRead'</code>) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to read from (directories end with a slash) [4] Fully qualified APL name of the item that Link intends to update [5] Name class of the APL item to be read <p>Note</p> <p>Do not assume a specific length, more elements may be added in the future.</p> <p>Your callback function must return one of the following results:   - <code>0</code>: The beforeRead function has completed all necessary actions. Link should not update the workspace.   - <code>1</code>: The beforeRead function wishes to \"pass\" on this read: Link should proceed as planned.</p>"},{"location":"API/Link.Create/#getfilename","title":"getFilename","text":"<p>If you specify a getFilename function, it will be called before Link updates a file or directory, allowing you to modify the name (or more likely the extension) of the file used to store the source for an APL item. Changing the file name this way allows you to override the caseCode, forceFilenames and forceExtensions options.</p> <p><code>getFilename</code> is a simple character vector containing the name of a function relative to the linked namespace.</p> <p>In the user command, simply give the name. For example: <code>]LINK.Create -getFilename=Foo ns /tmp/folder</code></p> <p>Your function will be called with a nested right argument containing the following elements:</p> Index Description [1] Event name (<code>'getFilename'</code>) [2] Reference to a namespace containing link options for the active link. [3] Fully qualified filename that Link intends to use (directories end with a slash) [4] Fully qualified APL name of the item [5] Name class of the APL item [6] Old APL name (different from APL name if the write is due to a rename) <p>Note</p> <p>Do not assume a specific length, more elements may be added in the future.</p> <p>Your callback function must return a simple character vector which must be one of:</p> <ul> <li>empty: to signify that Link should proceed with the suggested file name.</li> <li>non-empty: to specify the name to be used.</li> </ul>"},{"location":"API/Link.Create/#codeextensions","title":"codeExtensions","text":"<p>Default: <code>'aplf' 'aplo' 'apln' 'aplc' 'apli' 'dyalog' 'apl' 'mipage'</code></p> <p>Specify file extensions that are expected to contain source code. Link will only process changes to files with the specified extensions.</p> <p><code>var</code> is a nested vector of character vectors.</p> <p>From a user command, the syntax is <code>-codeExtensions=var</code> where <code>var</code> holds the expected vector of extensions.</p>"},{"location":"API/Link.Create/#customextensions","title":"customExtensions","text":"<p>Default: <code>''   \u235d an empty character vector meaning no custom extensions</code></p> <p>Specifies additional file extensions handled by beforeRead functions. </p> <p><code>customExtensions</code> is a nested vector of character vectors.</p> <p>From a user command, the syntax is <code>-customExtensions=var</code> where <code>var</code> holds the expected vector.</p> <p>If you have specified a beforeRead handler function, and your code supports the use of custom file extensions to store source data in application-specific formats, you need to set customExtensions so that Link does not ignore changes to these file types.</p> <p>The reason for splitting the list of extensions into two parts (codeExtensions and customExtensions) is to avoid your code having to repeat the list of standard extensions, or update this list if it should be extended in the future.</p>"},{"location":"API/Link.Create/#typeextensions","title":"typeExtensions","text":"<p>Default: <code>6 2\u23742 'apla' 3 'aplf' 4 'aplo' 9.1 'apln' 9.4 'aplc' 9.5 'apli'</code></p> <p>The typeExtensions table specifies the default extension that should be used when creating a new file to contain the source for an item of a given type. </p> <p>typeExtensions is a two-column matrix with numeric name class numbers in the first column and character vectors of corresponding file extensions in the second column. Note that, although you can change the extensions used, Link will add default definitions for any of the types that  you do not specify. For example, if you do not include a row for type 9.5, Link will use 'apli' for interfaces.</p> <p>From a user command, the syntax is <code>-typeExtensions=var</code> where <code>var</code> holds the expected array.</p> <p>Note that the forceExtensions switch can be used to correct all extensions on pre-existing files when a link is created.</p> <p>The default corresponds to:</p> Type extension 2 apla 3 aplf 4 aplo 9.1 apln 9.4 aplc 9.5 apli"},{"location":"API/Link.Create/#fastload","title":"fastLoad","text":"<p>Default: off</p> <p>The fastload flag will reduce the load time by not inspecting the source to detect name clashes.</p> <p>This affects only initial directory loading, but not subsequent editor or file system watcher events. It is worth setting fastLoad for very large projects that don't produce name clashes (that is, two files defining the same APL name). </p> <p>Side effects are (again, only at initial load time, not at subsequent events):</p> <ul> <li>good: load will be significantly faster because files won't be inspected to determine their true APL name.</li> <li>bad: clashing names won't be detected: files may silently overwrite each other's APL definition if they define the same APL name.</li> <li>bad: forceFilenames/forceExtensions won't be observed</li> <li>bad: beforeRead may report incorrect name class</li> </ul> <p>This option takes effect only when source is dir.</p>"},{"location":"API/Link.Create/#ignoreconfig_1","title":"ignoreconfig","text":"<p>Default: off</p> <p>Ignores any Link configuration files.</p> <p>See Configuration Files for details.</p>"},{"location":"API/Link.Create/#text","title":"text","text":"<p>Default: aplan</p> <p>Chooses whether plain text arrays are stored using APL Array Notation (APLAN) or as plain text files.</p> <p><code>text</code> is a simple character vector and must be either <code>'aplan'</code> or <code>'plain'</code>.</p> <p>See Array Formats for details.</p>"},{"location":"API/Link.Export/","title":"Link.Export","text":"<pre><code>]LINK.Export [ns] &lt;dir&gt; [-overwrite] [-casecode] [-arrays{=name1,name2,...}] [-sysvars] [-ignoreconfig] [-text={aplan|plain}]\n\nmsg \u2190 {opts} \u2395SE.Link.Export (ns dir)\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Export -?</code></p> <p>This function takes the same arguments as Link.Create but saves the contents of a namespace to directory without creating a Link.</p> <p>If the source is an unscripted namespace, then the destination is interpreted as a directory.</p> <p>If the source is anything else, then the destination is interpreted as a directory (and a correctly named file will be created there), unless it ends with a recognised extension (like <code>.aplf</code>), in which case it is interpreted as a file name.</p>"},{"location":"API/Link.Export/#arguments","title":"Arguments","text":"<ul> <li>ns : unscripted namespace or APL name. If ns is not provided, the default is to use the current namespace.</li> <li>dir: directory or file name</li> </ul>"},{"location":"API/Link.Export/#options","title":"Options","text":"<ul> <li><code>overwrite</code>: Allow overwriting existing files in the destination directory</li> <li>other options have same effect as in Link.Create</li> </ul>"},{"location":"API/Link.Export/#result","title":"Result","text":"<ul> <li>String describing the exported source and destination, along with possible failures</li> </ul>"},{"location":"API/Link.Expunge/","title":"Link.Expunge","text":"<pre><code>]LINK.Expunge &lt;item&gt;\n\n{available} \u2190  \u2395SE.Link.Expunge items\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Expunge -?</code></p> <p>This function is intended as a replacement for the system function <code>\u2395EX</code> in tools that manage code. It removes an item from the workspace and also deletes the corresponding source file.</p> <p>If you manually <code>)ERASE</code> items, you can subsequently call Expunge to remove the source file.</p>"},{"location":"API/Link.Expunge/#arguments","title":"Arguments","text":"<ul> <li>APL item name(s)</li> </ul>"},{"location":"API/Link.Expunge/#result","title":"Result","text":"<ul> <li>Simple Boolean vector with one element per name in the right argument.</li> </ul> <p>The value of an element of the result is 1 if the corresponding name is now available for use.  This does not necessarily mean that the existing value was erased for that name.  A value of  0 is returned for an ill-formed name or for a distinguished name in the argument.</p>"},{"location":"API/Link.Fix/","title":"Link.Fix","text":"<pre><code>{fixed} \u2190 {namespace} {name} {oldname} \u2395SE.Link. Fix src\n</code></pre> <p>This function is intended as a replacement for <code>\u2395FIX</code> or <code>\u2395FX</code> in environments in which some or all namespaces are linked. It will allow you to add or modify an array, function, operator, or scripted namespace, class or interface, without worrying about whether the namespace is linked. The source will be fixed in the target namespace, and the corresponding file will be created/updated if there is an active link which specifies that the namespace is being watched.</p> <p>For arrays, Fix expects the source to be Array Notation (you can use <code>\u2395SE.Dyalog.Array.Serialise</code> to produce it from array values). For other items, it uses the source in the form that would be produced by <code>\u2395NR</code> or <code>\u2395SRC</code>. In all cases the source is a vector of text vectors.</p> <p>Normally, one can use <code>\u2395FIX</code> or <code>\u2395FX</code> inside the target namespace, e.g. <code>myns.\u2395FIX 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}'</code> but since <code>Link.Fix</code> exists only as <code>\u2395SE.Link.Fix</code> then the target namespace must be explicitly specified as in <code>myns \u2395SE.Link.Fix 'avg\u2190{sum\u2190+\u233f\u2375' 'sum\u00f7\u2262\u2375}'</code>. The default namespace is the calling namespace.</p> <p>Note: If the item has already been updated or created and you only need to trigger an update of the source file, you can also use Link.Add.</p>"},{"location":"API/Link.Fix/#right-argument-source","title":"Right Argument: source","text":"<ul> <li>A vector of character vectors representing the source code of the item to be defined</li> </ul>"},{"location":"API/Link.Fix/#left-argument-namespace-name-oldname","title":"Left Argument: {namespace} {name} {oldname}","text":"<ul> <li>namespace: The namespace (by name or by reference) within which the source shall be fixed. Defaults to <code>''</code> which means the calling namespace.  </li> <li>name: The name of the item being defined. Defaults to <code>''</code> which means that the name will be defined by the source to be fixed. The name is required only for arrays, because their source doesn't contain their name.</li> <li>oldname: The old name of the fixed item, if this operation is a rename. Defaults to <code>name</code>, which means it is not a rename.</li> </ul>"},{"location":"API/Link.Fix/#result","title":"Result","text":"<ul> <li>The name of the item that was defined.</li> </ul>"},{"location":"API/Link.GetFileName/","title":"Link.GetFileName","text":"<pre><code>files \u2190  \u2395SE.Link.GetFileName items\n</code></pre> <p>Returns the fully qualified name of the file containing the source of the given APL item.  See also \u2395SE.Link.GetItemName.</p>"},{"location":"API/Link.GetFileName/#arguments","title":"Arguments","text":"<ul> <li>A simple vector with an APL item name, or a vector enclosed names. The result will have the same structure as the argument.</li> </ul>"},{"location":"API/Link.GetFileName/#result","title":"Result","text":"<ul> <li>For each APL item name: </li> <li>if item does not exist or does not belong to a linked namespace: empty vector</li> <li>otherwise: file name that the item is linked to</li> </ul>"},{"location":"API/Link.GetItemName/","title":"Link.GetItemName","text":"<pre><code>items \u2190  \u2395SE.Link.GetItemName files\n</code></pre> <p>Returns the name of the fully qualified APL item that is linked to a file. See also \u2395SE.Link.GetFileName.</p>"},{"location":"API/Link.GetItemName/#arguments","title":"Arguments","text":"<ul> <li>A simple vector containing a file name, or a vector of enclosed names. The result will have the same structure as the argument.</li> </ul>"},{"location":"API/Link.GetItemName/#result","title":"Result","text":"<ul> <li>For each file name:</li> <li>if file does not exist or does not belong to a linked directory: empty vector</li> <li>otherwise : item name that the file is linked to</li> </ul>"},{"location":"API/Link.Import/","title":"Link.Import","text":"<pre><code>]LINK.Import [ns] &lt;dir&gt; [-overwrite] [-flatten] [-fastload] [-ignoreconfig]\n\nmsg \u2190 {opts} \u2395SE.Link.Import (ns dir)\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Import -?</code></p> <p>This function takes the same arguments as Link.Create, but loads a directory containing source files into a namespace without creating an active link.</p> <p>If source is a directory, then its contents are imported into the destination namespace.</p> <p>If source is a single file, then the corresponding APL name is created in the destination namespace.</p>"},{"location":"API/Link.Import/#arguments","title":"Arguments","text":"<ul> <li>ns: namespace. If <code>ns</code> is not provided, it defaults to the current namespace.</li> <li>dir: directory or file name</li> </ul>"},{"location":"API/Link.Import/#options","title":"Options","text":"<ul> <li><code>overwrite</code>: Allow overwriting APL names in the destination namespace</li> <li>other options have same effect as in Link.Create</li> </ul>"},{"location":"API/Link.Import/#result","title":"Result","text":"<ul> <li>String describing the imported destination and source, along with possible failures</li> </ul>"},{"location":"API/Link.LaunchDir/","title":"Link.LaunchDir","text":"<pre><code>dir \u2190  \u2395SE.Link.LaunchDir\n</code></pre> <p>If APL was launched with a <code>LOAD</code> or <code>CONFIGFILE</code> parameter, <code>Link.LaunchDir</code> returns the fully qualified name of the directory in which the file used to start APL is located. If both were specified, the <code>LOAD</code>ed file takes priority.</p> <p>If neither parameter is specified, the current working directory is returned.</p> <p>This function is useful during the startup of applications loaded directly from source, and allows you to locate additional resources that are located relative to the source for the code used to start the application. For examples of usage, see setting up your environment</p>"},{"location":"API/Link.LaunchDir/#arguments","title":"Arguments","text":"<ul> <li>None</li> </ul>"},{"location":"API/Link.LaunchDir/#result","title":"Result","text":"<ul> <li>A character vector containing a fully qualified directory name.</li> </ul>"},{"location":"API/Link.Notify/","title":"Link.Notify","text":"<pre><code>{name} \u2190  \u2395SE.Link.Notify args\n</code></pre> <p>When synchonisation is active, Link will call Notify each time it detects a change to a linked source file.  If synchronisation is not enabled, you can use this function to bring an external change into the active workspace, to notify the link system that an external file has changed.</p> <p>If the workspace and directories become un-synchronised, you are probably better off using Link.Resync to get a list of differences, or Link.Refresh to completely re-load the external source.</p>"},{"location":"API/Link.Notify/#arguments","title":"Arguments","text":"<ul> <li> <p>type of event that happened</p> <ul> <li><code>'created'</code>: new file</li> <li><code>'changed'</code>: update to existing file</li> <li><code>'renamed'</code>: a file or subdirectory got a new name</li> <li><code>'deleted'</code>: a file or directory was erased</li> </ul> </li> <li> <p>path of affected file or directory</p> </li> <li> <p>oldpath is the previous path</p> </li> </ul> <p>can be omitted for all but a rename event</p>"},{"location":"API/Link.Notify/#result","title":"Result","text":"<ul> <li>If link updated an APL item, its full name is returned as a string. Otherwise an empty string is returned.</li> </ul>"},{"location":"API/Link.Refresh/","title":"Link.Refresh","text":"<pre><code>]LINK.Refresh &lt;ns&gt; [-source={ns|dir|auto}]\n\nmsg \u2190 {opts} \u2395SE.Link.Refresh ns\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Refresh -?</code></p> <p>Refresh will break and re-create a link by using one one side of the link as source, and bringing the other side into line.</p> <p>Note</p> <p>Refresh has the potential to lose changes: Refresh will overwrite one end of the link without checking for changes. Link.Resync provides better control, allowing you to review the differences before selecting how they should be resolved, and is now recommended in place of Refresh in most scenarios.</p> <p>Refresh is useful when you have decided not to watch one side of a link, but now want to pick up any changes that have happened since the link was created or most recently refreshed.</p> <ul> <li>To bring the workspace into line with the source directories, use <code>source=dir</code>.</li> <li>If you have made changes to linked namespaces using other mechanisms than the editor (such as using <code>\u2395FIX</code>, <code>\u2395FX</code>, <code>\u2395NS</code>, <code>\u2395CY</code> or assignment), you can Refresh with <code>source=ns</code> to update the directory.</li> </ul>"},{"location":"API/Link.Refresh/#arguments","title":"Arguments","text":"<ul> <li>namespace(s)</li> </ul>"},{"location":"API/Link.Refresh/#options","title":"Options","text":"<ul> <li>source    {ns|dir|auto}   <p>Whether to consider the ns or dir as the source for the link. - <code>dir</code> means that items in the namespace will be overwritten by items in files. - <code>ns</code> means that items in files will be overwritten by items in the namespace. - <code>auto</code> re-uses the same source that was determined at Create time.</p> <p>The default is to use the setting that was specified at creation (<code>auto</code>).</p> </li> </ul>"},{"location":"API/Link.Refresh/#result","title":"Result","text":"<ul> <li>String describing the established link, along with possible failures</li> </ul>"},{"location":"API/Link.Resync/","title":"Link.Resync","text":"<pre><code>]LINK.Resync &lt;ns&gt;\n\nmsg \u2190 {opts} \u2395SE.Link.Resync \u236c\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Resync -?</code></p> <p><code>Link.Resync</code> will re-synchronise the contents of linked namespaces and the corresponding source directories. It is useful when:</p> <ul> <li>You know that you have made changes of a type which will not trigger updates, such as function assignments or the <code>)COPY</code> system command</li> <li>You have reason to believe that the file system watcher might have missed some updates</li> <li>You have loaded a workspace that was saved with active links. In this case, all Link functionality will be disabled until you do a Resync to ensure that the workspace content matches the external source.</li> </ul> <p>By default, Resync takes no action, but outputs a list of differences found, with a recommendation of whether the the difference should be resolved by updating a file should be created or updated (<code>\u2192</code>), or that a file should be read and the workspace updated (<code>\u2190</code> ). For example:</p> <pre><code>      ]link.resync\n2 updates required: use -proceed option to synchronise\n Name          Direction  File             Comments\n #.badapp.Foo  \u2192                           Item has no corresponding file\n #.badapp.Goo  \u2190          /myapp/Goo.aplf  File is dated 08:17 yesterday,\n                                           WS copy is dated 03 Sep 2021 \n</code></pre> <p>If you accept the recommendations, you can add the <code>proceed</code> switch, after which the link will be up-to-date and work can proceed normally.</p> <pre><code>      ]link.resync -proceed\n1 file read, 1 file updated \n</code></pre> <p>If Link is not able to suggest an action, it will display <code>?</code> in the direction column, for example if the source file is now older than when it was loaded into the workspace, <code>-proceed</code> will be rejected, you will need to resolve the difference manually.</p> <p>Note</p> <p>Beware: The recommendations are NOT necessarily the correct actions! For example, if an item exists in the workspace but not on file, Resync will recommend creating the file (and vice versa if a file exists but the item is not found in the workspace). But if the file was intentionally removed or renamed in the source, the correct action is actually to delete or rename it in the workspace. Always review the recommendations carefully before <code>-proceed</code> ing. Of course, if you are using a source code management system like Git, you should easily be able to detect and recover from mistakes.</p>"},{"location":"API/Link.Resync/#arguments","title":"Arguments","text":"<ul> <li>ns: namespace(s) to consider</li> </ul>"},{"location":"API/Link.Resync/#options","title":"Options","text":"<ul> <li>proceed</li> </ul> <p>Whether to execute the changes suggested by Resync without the <code>proceed</code> option.</p> <ul> <li>arrays, sysvars</li> </ul> <p>Whether arrays and system variables should be included in the analysis. See Link.Create for details of these options.</p>"},{"location":"API/Link.Resync/#result","title":"Result","text":"<ul> <li>String describing the changes made, if requested.</li> </ul>"},{"location":"API/Link.Status/","title":"Link.Status","text":"<pre><code>]LINK.Status [&lt;ns&gt;] [-extended]\n\nstatus \u2190 {opts} \u2395SE.Link.Status ns\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Status -?</code></p> <p>This function provides information about existing links.</p>"},{"location":"API/Link.Status/#arguments","title":"Arguments","text":"<ul> <li>ns: namespace to look for links in (use <code>''</code> to list all links)</li> </ul>"},{"location":"API/Link.Status/#options","title":"Options","text":"<ul> <li>extended {0|1}</li> </ul> <p>Request additional information</p>"},{"location":"API/Link.Status/#result","title":"Result","text":"<ul> <li>Table of links <p>The first row contains column headers. First three columns are always:</p> </li> <li>namespace reference</li> <li>name of the linked directory or source file</li> <li>number of linked files and directories (excluding root directory) <p>If <code>extended</code> was specified, options settings for each link:</p> </li> <li>case code</li> <li>flatten</li> <li>force extensions</li> <li>force filenames</li> <li>watch</li> <li>paused</li> </ul>"},{"location":"API/Link.Stop/","title":"Link.Stop","text":""},{"location":"API/Link.Stop/#syntax","title":"Syntax","text":"<pre><code>]LINK.Stop &lt;name&gt; [lines]\n\nmessage \u2190 \u2395SE.Link.Stop name [lines]\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Stop -?</code></p> <p>This function allows you to set stops on selected lines of a function or operator. It will also store the setting in the <code>.linkconfig</code> file for the directory, so that the stops will be re-applied the next time the directory is linked, as would be the case if the stops were set using the editor.</p>"},{"location":"API/Link.Stop/#arguments","title":"Arguments","text":"<ul> <li><code>name</code> is the name of an existing function or operator.  </li> <li><code>lines</code> is a list of integer line numbers, or \"\u236c\" to clear all stops.  </li> </ul>"},{"location":"API/Link.Stop/#result","title":"Result","text":"<ul> <li><code>message</code> is a simple character vector containing the previous settings.</li> </ul>"},{"location":"API/Link.StripCaseCode/","title":"Link.StripCaseCode","text":"<pre><code>files \u2190 {opts} \u2395SE.Link.StripCaseCode files\n</code></pre> <p>If case codes is on (default is off), each file name will have a case code. </p> <p>If you set up a <code>beforeRead</code> hook when creating a Link, Link will allow your prompt your hook take appropriate action before a file is imported. If the filename may have a case code. The StripCaseCode function is provided to remove case coding from any file name.</p>"},{"location":"API/Link.StripCaseCode/#arguments","title":"Arguments","text":"<ul> <li>file name(s)</li> </ul>"},{"location":"API/Link.StripCaseCode/#result","title":"Result","text":"<ul> <li>file name(s) without case code</li> </ul>"},{"location":"API/Link.Trace/","title":"Link.Trace","text":""},{"location":"API/Link.Trace/#syntax","title":"Syntax","text":"<pre><code>]LINK.Trace &lt;name&gt; [lines]\n\nmessage \u2190 \u2395SE.Link.Trace name [lines]\n</code></pre> <p>Show User Command information in the session with <code>]LINK.Trace -?</code></p> <p>This function allows you to set trace bits on selected lines of a function or operator. It will also store the setting in the <code>.linkconfig</code> file for the directory, so that the trace settings will be re-applied the next time the directory is linked, as would be the case if they were set using the editor.</p>"},{"location":"API/Link.Trace/#arguments","title":"Arguments","text":"<ul> <li><code>name</code> is the name of an existing function or operator.  </li> <li><code>lines</code> is a list of integer line numbers, or \"\u236c\" to clear all settings.</li> </ul>"},{"location":"API/Link.Trace/#result","title":"Result","text":"<ul> <li><code>message</code> is a simple character vector containing the previous settings.</li> </ul>"},{"location":"API/Link.TypeExtension/","title":"Link.TypeExtension","text":"<pre><code>ext \u2190 opts \u2395SE.Link.TypeExtension nc\n</code></pre> <p>This function is used internally by Link, but is also available for use when implementing extensions to Link using exits like <code>beforeRead</code> and <code>beforeWrite</code>.</p>"},{"location":"API/Link.TypeExtension/#right-argument","title":"Right Argument","text":"<ul> <li>nameclass of item</li> </ul>"},{"location":"API/Link.TypeExtension/#left-argument","title":"Left argument","text":"<ul> <li>link options namespace used as left argument of Link.Create</li> </ul>"},{"location":"API/Link.TypeExtension/#result","title":"Result","text":"<ul> <li>character vector of the extension (without leading <code>'.'</code>)\\ Note that extension will be (<code>,'/'</code>) for unscripted namespaces (name class <code>\u00af9</code>) because they map to directories</li> </ul>"},{"location":"API/Link.Version/","title":"Link.Version","text":"<pre><code>version \u2190  \u2395SE.Link.Version\n</code></pre> <p>This niladic function returns the current Link semantic version number as a string in the format <code>'X.Y.Z'</code>, where X Y and Z are non-negative integers. Development or experimental versions will have a trailing hyphen and string such as <code>'X.Y.Z-alpha3'</code>.</p>"},{"location":"Discussion/History/","title":"History of source files as text in Dyalog","text":"<p>Link is another step in the journey from binary workspaces to APL source in text files.</p>"},{"location":"Discussion/History/#workspaces","title":"Workspaces","text":"<p>Historically, APL systems have used saved workspaces as the way to store the current state of the interpreter in a binary file which contains a collection of code and data. In many ways, a workspace is similar to a workbook saved by a spreadsheet application; a very convenient package that contains everything the application needs to run. Saving the workspace at the end of a run preserves updated data, as well as any code changes that might have been made.</p>"},{"location":"Discussion/History/#component-files-and-sql-databases","title":"Component Files and SQL Databases","text":"<p>Workspaces are very convenient, but the binary format makes them awkward if you want to compare, or otherwise manage, different versions of the source code - or the data, for that matter. Users preferred to store their data in component files or other storage mechanisms. As teams started writing larger systems, many development teams also created their own source code management systems (SCMs), typically storing multiple versions of code in component files or SQL tables.</p> <p>These SCMs served large developer teams well for several decades. However, none of them became tools that were shared by the APL community, and they all suffered from the fundamental problem of using binary formats.</p>"},{"location":"Discussion/History/#salt-the-simple-apl-library-toolkit","title":"SALT - the Simple APL Library Toolkit","text":"<p>In 2006, Dyalog APL Version 11.0 introduced Classes and the ability to represent Namespaces as text \"scripts\". With that release, Dyalog APL included a tool known as SALT, which supported the use of Unicode text files as backing for the source of not only classes and namespaces, but functions, operators and variables as well. At the same time, a component named SPICE added user commands to Dyalog APL, using text source files which implemented a specific API, based on SALT's file handling.</p> <p>SALT is Link's direct predecessor, and has many of the same features as Link:</p> <ul> <li>The ability to load entire directory structures into the workspace as namespaces</li> <li>A tool called \"Snap\", which would write all or selected parts of a workspace to corresponding source files.</li> <li>A hook in the APL system editor, which would update source files as soon as code was edited, without requiring a separate save operation.</li> <li>Startup processing of files with a <code>.dyapp</code> extension, to allow launching applications from text files without requiring a \"boot workspace\".</li> </ul>"},{"location":"Discussion/History/#link-20","title":"Link 2.0","text":"<p>After SALT had grown organically for more than a decade, it was decided that this functionality should be re-implemented in a new system: the Link project began. The first version of Link that was released to the general public was 2.0. The main differences between Link and SALT are:</p> <ul> <li>Link delegates the task of maintaining information about external source files to the APL interpreter, rather than using a trailing comment in functions and operators or \"hidden\" namespaces for classes and namespaces to track this information.</li> <li>New interpreter functionality based on <code>2 \u2395FIX</code> makes it possible for the interpreter to preserve source code exactly as typed, when an external source file is used.</li> <li>A file system watcher added support for using external editors and immediately replicating the effect of SCM system actions, such as a git pull or revert operation, inside the active workspace.</li> <li>Rather than using the extension <code>.dyalog</code> for all source, Link uses different extensions for different types of source, such as <code>.aplf</code> for functions, <code>.apln</code> for namespaces, and <code>.apla</code> for arrays.</li> <li>Use of a model of the proposed Literal Array Notation to represent arrays, rather than the notation used by SALT.</li> <li> <p>We hope to add support for the array notation to the Dyalog APL interpreter in a future release.</p> </li> <li> <p>Link has no source code management features; the expectation is that users who require SCM will combine Link with an external SCM such as Git or SVN</p> </li> <li>SALT included a simple mechanism for storing and comparing multiple versions of the source for an object by injecting digits into the file name.</li> </ul>"},{"location":"Discussion/History/#link-30-dyalog-version-182-2022","title":"Link 3.0 (Dyalog version 18.2, 2022)","text":"<p>Link 3.0 is the first major revision of Link. It added:</p> <ul> <li>Support for saving workspaces containing links and resuming work after a break.</li> <li>Support for names which differ only in case (for example, <code>FOO</code> vs <code>Foo</code>) in case-insensitive file systems, by adding \"case coding\" information to the file name.</li> <li>The <code>Link.LaunchDir</code> API function, makes it straightforward to determine the folder that APL was launched on, simplifying the task of  launching the interpreter using a configuration file or single APL source file.</li> <li>Dyalog version 18.2, released at the same time as Link 3.0, supports identifying a directory with the <code>LOAD=</code> parameter - as an alternative to a workspace, APL source file, or a configuration file. When <code>LOAD</code> identifies a directory, a link will be created on startup (and the function <code>Run</code> invoked, if it exists).</li> </ul> <p>A more complete description of Link 3.0 and the differences between Link 2.0 and 3.0 can be found in the Link 3.0 documentation.</p>"},{"location":"Discussion/History/#link-40-dyalog-version-190-2024","title":"Link 4.0 (Dyalog version 19.0, 2024)","text":"<p>Link 4.0 was the companion release to Dyalog version 19.0 in 2024. The most important new features are:</p> <ul> <li>Configuration files to store options for a user or a source code folder</li> <li>The ability to store multi-line character data in plain text files</li> <li>Support for linking a single source file defining a namespace or class</li> </ul> <p>Link 4.0 is upwards compatible with Link 3.0, and can also be used with Dyalog version 18.2.</p>"},{"location":"Discussion/History/#link-41-dyalog-version-200-2025","title":"Link 4.1 (Dyalog version 20.0, 2025)","text":"<p>Link 4.1 was the companion release to Dyalog version 20.0 in 2025. In this release, we've focused on improving stability and preformance, expecially when a large number files are changed simultaneously. We've also fixed a number of bugs.</p> <p>Link 4.1 is upwards compatible with Link 4.0, and can also be used with Dyalog version 19.0.</p>"},{"location":"Discussion/TechDetails/","title":"Technical Details and Limitations","text":"<p>Link enables the use of text files as application source by mapping workspace content to directories and files. There are some types of objects that cannot be supported, and a few other limitations to be aware of.</p>"},{"location":"Discussion/TechDetails/#supported-objects","title":"Supported Objects","text":"<p>In the following, for want of a better word, the term object will be used to refer to any kind of named entity that can exist in an APL workspace - not limited to classes or instances.</p> <p>Supported: Link supports objects of name class 2.1 (array), 3.1 (traditional function), 3.2 (d-function), 4.1 (traditional operator), 4.2 (d-operator), 9.1 (namespace), 9.4 (class) and 9.5 (interface).</p> <p>Unscripted Namespaces: Namespaces created with <code>\u2395NS</code> or <code>)NS</code> have no source code of their own and are mapped to directories.</p> <p>Classes and Scripted Namespaces: Classes and so-called scripted namespaces created using the editor or <code>\u2395FIX</code>, have textual source and are treated the same way as functions and other \"code objects\". Support for scripted namespaces as endpoints for a Link was introduced in Link 4.0. Before 4.0, scripted namespaces were allowed only as objects within a an unscripted linked namespace.</p> <p>Note that unnamed namespaces are NOT supported, either as endpoints of a Link or indeed within a linked namespace: Changes to - or within - unnamed namespaces will be ignored by Link. This is discussed in more detail in the next section.</p> <p>Variables are ignored by default, because most of them are not part of the source code of an application. However, they may be explicitly saved to file with Link.Add, or with the <code>-arrays</code> modifier of Link.Create and Link.Export.</p> <p>Functions and Operators: Link is not able to represent names which refer to primitive or derived functions or operators, or trains. You will need to define such objects in the source of another function, or a scripted namespace. For example, the derived function <code>Pairs\u2190\u22a2\u233a(\u236a2 2)</code> cannot be represented directly. However, inclusion of the following tradfn will have the desired effect: <pre><code>\u2207 F\u2190Pairs\n  F\u2190\u22a2\u233a(\u236a2 2)\n\u2207\n</code></pre></p> <p>Note</p> <p>If you use assignment (rather than the editor) to turn an operator into a function, the file extension will not be changed. You will need to rename the file by hand for consistency.</p> <p>Unsupported: In addition to unnamed namespaces, Link has no support for name classes 2.2 (field), 2.3 (property), 2.6 (external/shared variable), 3.3 (primitive or derived function or train), 4.3 (primitive or derived operator), 3.6 (external function) 9.2 (instance), 9.6 (external class) and 9.7 (external interface). These can be listed with <code>]names 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7</code> and listed for the namespace <code>myns</code> with <code>]names myns 2.2 2.3 2.6 3.3 4.3 3.6 9.2 9.6 9.7</code>.</p>"},{"location":"Discussion/TechDetails/#other-limitations","title":"Other Limitations","text":"<ul> <li>Namespaces must be named. To be precise, it must be true that <code>ns\u2261(\u2395NS\u236c)\u234e\u2355ns</code>. Scripted namespaces must not be anonymous. When creating an unscripted namespace, we recommend using <code>\u2395NS</code> dyadically to name the created namespace (for example <code>'myproject' \u2395NS \u236c</code> rather than <code>myproject\u2190\u2395NS \u236c</code>). This allows retrieving namespace reference from its display form (for example <code>#.myproject</code> rather than <code>#.[namespace]</code>).</li> </ul> <p>Changes to - or within - unnamed namespaces will be ignored.</p> <ul> <li>There must be exactly one file in the directory per named item to be created in the workspace. In particular, you must not have more than one file defining the same object: this will be reported as an error on Link.Create or Link.Import.</li> </ul> <p>In other words, Link does not support source files that define multiple names, even though <code>2\u2218\u2395FIX</code> does support this.</p> <ul> <li> <p>In a case-insensitive file system, Links created with default options cannot contain names which differ only in case, because the source files would have indistinguishable names. The <code>caseCode</code> option can be used to get Link to generate file names which encode case information - see Link.Create for more information.</p> </li> <li> <p>Link does not support namespace-tagged functions and operators (e.g. <code>foo\u2190namespace.{function}</code>).</p> </li> <li> <p>Changes made using <code>\u2190</code>, <code>\u2395NS</code>, <code>\u2395FX</code>, <code>\u2395FIX</code>, <code>\u2395CY</code>, <code>)NS</code> and <code>)COPY</code> are not currently detected. For Link to be aware of the change, a call must be made to Link.Fix. Similarly, deletions with <code>\u2395EX</code> or <code>)ERASE</code> must be replaced by a call to Link.Expunge.</p> </li> <li> <p>The detection of external changes to files and directories is currently only supported if a supported flavour of .NET is available to the interpreter. Note that the built-in APL editor will detect changes to source files on all platforms, when it opens an editor window.</p> </li> <li> <p>Source code must not have embedded newlines within character constants. Although <code>\u2395FX</code> does allow this, Link will error if this is attempted. This restriction comes because newline characters would be interpreted as a new line when saved as text file. When newline characters are needed in source code, they should be implemented by a call to <code>\u2395UCS</code> e.g. <code>newline\u2190\u2395UCS 13 10  \u235d carriage-return + line-feed</code></p> </li> </ul> <p>Note</p> <p>If you are still using the pre-Unicode version of Dyalog known as \"Classic\": Link will work, but names which contain characters other than a-z, A-Z, 0-9 and _ will cause Link to create strange file names. For example <code>]add \u2395IO</code> will cause the creation of a file named <code>\u0152IO.apla</code>. Depending on the names of your objects,  this may make it difficult to share source files between Classic and Unicode interpreters.</p>"},{"location":"Discussion/TechDetails/#how-does-link-work","title":"How does Link work?","text":"<p>Some people need to know what is happening under the covers before they can relax and move on. If you are not one of those people, do not waste any further time on this section. If you do read it, understand that things may change under the covers without notice, and we will not allow a requirement to keep this document up-to-date to delay work on the code. It is reasonably accurate as of March 2025, at the end of the Link 4.1 development cycle.</p> <p>Terminology: In the following, the term object is used very loosely to refer to functions, operators, namespaces, classes and arrays.</p>"},{"location":"Discussion/TechDetails/#what-exactly-is-a-link","title":"What Exactly is a Link?","text":"<p>A link connects a namespace in the active workspace (which can be the root namespace <code>#</code>) to a directory in the file system. </p> <p>When a link is created:</p> <ul> <li> <p>An entry is created in the table which is stored in the workspace using an undocumented I-Beam, recording the endpoints and all options associated with the Link. Link.Status can be used to report this information. Earlier versions used <code>\u2395SE.Link.Links</code>, but versions 3.0 and later only store information on links with an endpoint in <code>\u2395SE</code> in that variable.</p> </li> <li> <p>Depending on which end of the link is specified as the source, APL source files are created from workspace definitions, or objects are loaded into the workspace from such files. These processes are described in more detail in the following sections.</p> </li> <li> <p>If .NET is available, a .NET File System Watcher is created to watch the directory for changes so that those changes can immediately be replicated in the workspace (unless an option is set to prevent this).</p> </li> </ul>"},{"location":"Discussion/TechDetails/#creating-apl-source-files-and-directories","title":"Creating APL Source Files and Directories","text":"<p>Link writes textual representations of APL objects to UTF-8 text files (but can load source files created using any Unicode encoding). Most of the time, it uses the system function <code>\u2395SRC</code> to extract the source form writing it to file using <code>\u2395NPUT</code>. There are two exceptions to this:</p> <ul> <li>So-called \"unscripted\" namespaces, which contain other objects but do not themselves have a textual source, are represented as sub-directories in the file system (which may contain source files for the objects within the namespace).</li> <li>Arrays are converted to source form using the function <code>\u2395SE.Dyalog.Array.Serialise</code>. It is expected that the APL language engine will, in the future, support the \"literal array notation\".</li> </ul>"},{"location":"Discussion/TechDetails/#loading-apl-objects-from-source","title":"Loading APL Objects from Source","text":"<p>With the exception of variables stored in <code>.apla</code> files, Link loads code into the workspace using <code>2 \u2395FIX</code>. </p> <p>Arrays, stored in <code>.apla</code> files, are either processed by <code>\u2395SE.Dyalog.Array.Deserialise</code> or, if in plain text format (in which case they have a \"sub-extension\", for example <code>.mat.apla</code>), by Link itself.</p> <p>When you are watching both sides of a link, Link delegates the work of tracking the links to the interpreter. In this case, editing objects will cause the editor itself (not Link) to update the source file. You can inspect the links which are maintained by the interpreter using a family of I-Beams numbered 517x. When a new function, operator, namespace or class is created, a hook in the editor calls Link code which generates a new file and sets up the link.</p> <p>If .NET is available, Link uses a File System Watcher to monitor linked directories and immediately react to file creation, modification or deletion.</p>"},{"location":"Discussion/TechDetails/#the-source-of-link-itself","title":"The Source of Link itself","text":"<p>Link consists of a set of API functions which are loaded into the namespace <code>\u2395SE.Link</code>, when APL starts, from $DYALOG/StartupSession/Link. The user command file $DYALOG/SALT/SPICE/Link.dyalog provides access to the interactive user command covers that exist for most of the API functions. Link 4.1 is pre-installed with Dyalog version 20.0 or later. To use version 4.1 with Dyalog 19.0, see the installation instructions.</p>"},{"location":"Discussion/TechDetails/#the-crawler","title":"The Crawler","text":"<p>In a future version of Link, an optional and configurable crawler will be able to run in the background and occasionally compare linked namespaces and directories, using the same logic as Link.Resync, and deal with anything that might have been missed by the automatic mechanisms. This will be especially useful if:</p> <ul> <li>The File System Watcher is not available on your platform</li> <li>You add functions or operators to the active workspace without using the editor, for example using <code>)COPY</code> or dfn assignment.</li> </ul> <p>The section on supported objects provides much more information about the type of APL objects that are supported by Link.</p>"},{"location":"Discussion/TechDetails/#breaking-links","title":"Breaking Links","text":"<p>If Link.Break is used to explicitly break an existing Link the namespace reverts to being a completely \"normal\" namespace in the workspace. If file system watcher was active, it is disabled. Any information that the interpreter was keeping about connections to files is removed using <code>5178\u2336</code>. None of the definitions in the namespace are modified by the process of breaking a link.</p> <p>If you delete a linked namespace using <code>)ERASE</code> or <code>\u2395EX</code>, Link may not immediately detect that this has happened. However, if you call <code>Link.Status</code>, or make a change to a watched file that causes the file system watcher to attempt to update the namespace, Link will discover that something is amiss, issue a warning, and delete the link.</p> <p>If you completely destroy the active workspace using <code>)LOAD</code> or <code>)CLEAR</code>, all links with an endpoint in the workspace will be deleted - but links to <code>\u2395SE</code> will survive.</p>"},{"location":"Discussion/TechDetails/#the-future","title":"The Future","text":"<p>To summarise, the Link road map currently includes the following goals:</p> <ul> <li>Adding the crawler, which will automatically run Link.Resync in the background, in order to detect and help eliminate differences between the contents of linked namespaces and the corresponding directories. It may replace the File System Watcher in environments where it is not available.</li> <li>Replacing the use of SALT in Dyalog's tools, including a new implementation of user commands and other mechanisms for loading source code into the interpreter based on Link instead.</li> </ul> <p>Over time, it is a strategic goal for Dyalog to move more of the work done by Link into the APL interpreter, such as:</p> <ul> <li>Serialisation and deserialisation of arrays, using the literal array notation</li> <li>File system watching or other mechanisms for detecting changes to source at both ends of a link</li> </ul>"},{"location":"Discussion/Workspaces/","title":"Workspaces","text":""},{"location":"Discussion/Workspaces/#link-versus-workspaces","title":"Link versus Workspaces","text":"<p>As the versus in the heading is intended to imply, the main purpose of Link is to replace many uses of workspaces. Link is intended to make it possible for APL users to move away from the use of workspaces as a mechanism for storing APL source code.</p>"},{"location":"Discussion/Workspaces/#are-workspaces-dead-now","title":"Are Workspaces Dead Now?","text":"<p>No: Workspaces still have many uses, even if they are falling out of favour as mechanism for source code management:</p> <ul> <li>Distribution: For large applications, it will be inconvenient or undesirable to ship large collections of source files that are loaded at startup. The use of workspaces as a mechanism for the distribution of packaged collections of code and data is expected to continue.</li> <li>Crash Analysis: When an application fails, it is often useful to save the workspace, complete with execution stack, code and data, for subsequent analysis and sometimes resumption of execution. Dyalog will continue to support this, although we may gradually impose some restrictions, for example requiring the same version and variant of the interpreter in order to resume execution of a saved workspace.</li> <li>Pausing work: In many ways, this is similar to crash analysis: sometimes you need to shut down your machine in the middle of things and resume later, but you don't want to be forced to start from scratch because you have created an interesting scenario with data in the workspace. Saving a workspace allows you to do this.</li> </ul> <p>With the exception of the scenarios mentioned above, Link is intended to make it unnecessary to save workspaces. All source code changes that you make while editing or tracing your code should immediately end up in text files and be managed using an SCM. The normal workflow is to start each APL session by loading the code into the workspace from source directories. You might want to save a \"stub\" workspace that contains a very small amount of code that loads everything else from text source, but from version 18.0 of Dyalog APL you can now easily set that up using text files as well, rendering workspaces obsolete as part of your normal development workflow.</p>"},{"location":"Discussion/Workspaces/#saving-workspaces-containing-links","title":"Saving workspaces containing Links","text":"<p>If you <code>)SAVE</code> a workspace which has active links in it, this creates a potential conflict between the source code embedded in the workspace and any changes that may have been made to external source since the workspace was saved. If you <code>)LOAD</code> a saved workspace, Link will issue a warning along the lines of:</p> <pre><code>IMPORTANT: 1 namespace linked in this workspace: #.myapp\nIMPORTANT: Link.Resync is required\n</code></pre> <p>Except for a few reporting tools like Link.Status, link user commands and API functions will be disabled, until you run Link.Resync, which will compare the contents of the workspace and the source directories, list the differences and propose actions to take in order to bring the contents of the workspace in line with the source folders.</p> <p>Note</p> <p>Beware: If you continue working without doing a Resync, strange things may happen: Link user commands and API functions will refuse to perform any actions, but names defined in the linked namespace contain references to external source files that the interpreter and editor will still honour. Using the built-in editor will read the external source file at the start of an editing session, and any changes made will be written to file, even though Link itself remains disabled.</p> <p>In other words, you should NOT continue working without a Resync, unless you have a very good reason to do so and understand exactly what might happen.</p>"},{"location":"Discussion/Workspaces/#distribution","title":"Distribution","text":"<p>If you want to distribute a workspace created using Link to import code, note that if the workspace is loaded on a machine where the recorded source file names are not valid, this will lead to confusion. Application workspaces should always be built using Link.Import. Alternatively, use Link.Break to remove the links before you <code>)SAVE</code> the workspace.</p> <p>Note</p> <p>If you automate a build process using Link.Create rather than Link.Import, immediately followed by a <code>\u2395SAVE</code>, there is a significant chance that a File System Watcher callback will be running in a separate thread, which will cause the <code>\u2395SAVE</code> to fail.</p> <p>See the discussion about setting up your environment for more tips on creating development and runtime environments.</p>"},{"location":"Usage/","title":"Basic Usage","text":"<p>These sections cover the most commonly used commands. For more advanced usage, please consult the API documentation.</p>"},{"location":"Usage/#starting-from-an-existing-folder-containing-text-files","title":"Starting from an existing folder containing text files","text":"<p>Use Link.Create to Link a directory containing text source to a namespace in the active workspace.</p> <p>The following example loads APL code from the folder /users/sally/myapp into a namespace called <code>myapp</code>.</p> <pre><code>      \u2395SE.Link.Create myapp '/users/sally/myapp'\n</code></pre> <p>For ad hoc use in an interactive session, it might be more convenient to use the user command: <pre><code>      ]LINK.Create myapp /users/sally/myapp\n</code></pre></p>"},{"location":"Usage/#linking-a-directory-on-startup","title":"Linking a directory on startup","text":"<p>If you are using Dyalog version 18.2 or later, you can cause a link to be created to the root of your workspace (<code>#</code>) as APL starts, by setting the <code>LOAD</code> parameter on the command line or as an environment variable. After establishing the link, the system will call the function <code>Run</code> with a right argument containing the name of the directory. You can disable the call to <code>Run</code> by including the <code>-x</code> switch on the command line (in the same way that the <code>-x</code> switch inhibits the execution of the latent expression when loading a workspace).</p> <p>With a standard Dyalog 18.2 installation under Microsoft Windows, you can also right click on a directory and select \"Open with Dyalog\" or \"Run with Dyalog\" to create a link on startup and optionally call <code>Run</code>.</p>"},{"location":"Usage/#importing-code-without-creating-a-link","title":"Importing code without creating a link","text":"<p>Sometimes you want to load some code in order to run it, without intending to make any modifications - or you might want to experiment and make modifications to the code, but want to be sure that the source files are not updated. Use Link.Import to bring code from text source files into the active workspace without creating a link. The syntax of Import is almost identical to Create. The important difference being that changes to code in the workspace or in source files are not tracked or acted upon following an Import. For example:</p> <pre><code>      ]LINK.Import myapp /users/sally/myapp\n</code></pre>"},{"location":"Usage/#starting-a-new-project","title":"Starting a new project","text":"<p>If you are starting a completely new project, you can either create a namespace in the active workspace, or a folder on the file system (or both), and use Link.Create, naming the namespace and the folder, as in the example at the start of this page.</p> <ul> <li>If neither of them exist, Link.Create will reject the request on suspicion that there is a typo, in order to avoid silently creating an empty directory by mistake.</li> <li>If both of them exist AND contain code, and the code is not identical on both sides, Link.Create will fail and you will need to specify the  <code>source</code> option, whether the namespace or the directory should be considered to be the source. Incorrectly specifying the source will potentially overwrite existing content on the other side, so use this with extreme caution!</li> </ul> <p>To illustrate, we will create a namespace and populate it with two dfns and one tradfn, in order to have something to work with. In this example, the functions are created using APL expressions; under normal use the functions would probably be created using the editor, or perhaps loaded or copied from an existing workspace.</p> <p><pre><code>      'stats' \u2395NS \u236c \u235d Create an empty namespace\n      stats.\u2395FX 'mean\u2190Mean vals;sum' 'sum\u2190+\u233f,vals' 'mean\u2190sum\u00f71\u2308\u2374,vals'\n      stats.Root\u2190{\u237a\u21902 \u22c4 \u2375*\u00f7\u237a}\n      stats.StdDev\u2190{2 Root(+.\u00d7\u2368\u00f7\u2374),\u2375-Mean \u2375}\n</code></pre> We could now create a source directory using Link.Export, and then use Link.Create to create a link to it. However, Link.Create can do this in one step: assuming that the directory <code>/users/sally/stats</code> is empty or does not exist, the following command will detect that there is code in the namespace but not in the directory, and create a link based on the namespace that we just populated with our functions:</p> <p><pre><code>      ]LINK.Create stats /users/sally/stats\nLinked: #.stats \u2190\u2192 C:\\tmp\\stats\n</code></pre> The double arrow <code>\u2190\u2192</code> in the output indicates that synchronisation is bi-directional. If .NET is not available, the default will be to only replicate changes in the namespace to file, which will be indicated by a <code>\u2192</code>. We can check that the three expected files have been created:</p> <p><pre><code>      ls\u2190\u2395NINFO\u23601 \u235d List files, allowing wildcards\n      ls '/users/sally/stats/*'\n  /users/sally/stats/Mean.aplf  /users/sally/stats/Root.aplf  \n  /users/sally/stats/StdDev.aplf  \n</code></pre> We can also verify that the new source directory can be used to re-build the original namespace::</p> <pre><code>      )CLEAR\nclear ws\n      ]LINK.Create stats /users/sally/stats\nLinked: stats \u2190\u2192 users/sally/stats\n      stats.\u2395NL -3 \u235d Verify functions were loaded as expected\n Mean  Root  StdDev\n</code></pre>"},{"location":"Usage/#starting-a-project-from-a-workspace","title":"Starting a project from a workspace","text":"<p>If your existing code is in a workspace rather than in text files, you should read the section on converting a workspace to source files before continuing.</p>"},{"location":"Usage/#saving-your-work","title":"Saving your work","text":"<p>Once a link is set up using Link.Create, you can work with your code using the Dyalog exactly as you would if you were not using Link; the only difference being that Link will ensure that any changes you make (using the APL editor) to the code within the <code>stats</code> namespace are instantly copied to the corresponding source file.</p> <p>In the context of this document, the term Dyalog IDE includes both the Windows IDE and the Remote IDE (RIDE), which is tightly integrated with the interpreter.</p> <p>The use of a source code management system like Git is recommended. If you do that, then you effectively save your work by doing a commit.</p> <p>Conversely, if you are new to Dyalog APL, and have a favourite editor, you can use it to edit the source files directly, and any changes that you make will be replicated in the active workspace - assuming that .NET (Framework, or 6.0 and later versions) is available and your APL system is configured to use it.</p> <p>Note</p> <p>Note that, although a so-called .NET File System Watcher (FSW) is useful for immediately picking up changes made using an external editor, a FSW is NOT a reliable mechanism for deployment of new code to running systems. For example, running a server with an active link and patching it simply by modifying linked source files IS NOT RECOMMENDED.</p> <p>If you use editors inside or outside the APL system to add new functions, operators, namespaces or classes,  the corresponding change will be made on the other side of the link. For example, we could add a <code>Median</code> function to the namespace we created earlier:</p> <pre><code>      )ED stats.Median\n</code></pre> <p>In the Edit window, we complete the function:</p> <pre><code>Median\u2190{\n     asc\u2190\u234bvals\u2190,\u2375\n     Mean vals[asc[\u23082\u00f7\u23680 1+\u2374vals]]\n }\n</code></pre> <p>When the editor fixes the definition of the function in the workspace, Link will create a new file:</p> <pre><code>      ls '/users/sally/stats/*'\n  /users/sally/stats/Mean.aplf  /users/sally/stats/Root.aplf  \n  /users/sally/stats/StdDev.aplf /users/stats/StdDev.aplf  \n</code></pre>"},{"location":"Usage/#viewing-the-status-of-links","title":"Viewing the status of links","text":"<p>The function (and corresponding user command) Link.Status will show namespaces that are currently linked and the folders to which they are linked. For example:</p> <pre><code>       ]link.status\n Namespace  Source               Files\n #.stats    /users/sally/stats       4  \n</code></pre>"},{"location":"Usage/#un-linking-a-namespace","title":"Un-Linking a namespace","text":"<p>To continue using code in the active workspace without the risk of updating text source files or picking up changes made using external editors, use Link.Break.</p> <p>Clearing the workspace, for example using <code>)CLEAR</code>, or exiting Dyalog, for example with <code>)OFF</code>, will also break all links in the active workspace.</p> <p>See the technical details on breaking links for more information, for example about what happens when you delete a linked namespace from the active workspace.</p>"},{"location":"Usage/#changes-made-outside-the-editor","title":"Changes made outside the Editor","text":"<p>When changes are made using the editor which is built-in to Dyalog APL (Windows IDE or RIDE), source files are updated immediately. Changes made outside the editor will not immediately be picked up. This includes:</p> <ul> <li>Definitions created or changed using assignment (<code>\u2190</code>), <code>\u2395FX</code>  or <code>\u2395FIX</code>.</li> <li>Definitions moved between workspaces or namespaces using <code>\u2395CY</code>, <code>\u2395NS</code> or <code>)COPY</code>.</li> <li>Definitions erased using <code>\u2395EX</code>or <code>)ERASE</code></li> </ul> <p>If you write tools which modify source code under program control, such as linters or search/replace tools, you should call the API functions Link.Fix or Link.Expunge to update the definitions, so that Link can take appropriate action such as updating source files.</p> <p>If you update the source files under program control and inbound synchronisation is not enabled, you can use Link.Notify to let Link know about an external change that you would like to bring into the workspace.</p>"},{"location":"Usage/#arrays","title":"Arrays","text":"<p>By default, Link does not consider arrays to be part of the source code of an application and will not write arrays to source files unless you explicitly request it. Link is not intended to be used as a database management system; if you have arrays that are modified during the normal running of your application, we recommend that you store that data in an RDBMS or other files that are managed by the application code, rather than using Link for this.</p> <p>However, if you have arrays that represent error tables, range definitions or other constant definitions that it makes sense to conside to be part of the source code, you can add them using Link.Add:</p> <pre><code>      stats.Directions\u2190'North' 'South' 'East' 'West'\n      ]Link.Add stats.Directions\nAdded: #.stats.Directions\n</code></pre> <p>By default, Link uses APL Array Notation to store arrays in text files. Link 4.0 introduced experimental support for storing multi-line character data in simple text files. For more information, see the section on array formats.</p> <p>Once you have created a source file for an array, Link will update that file if you use the editor to modify the array. Only if you modify the array using assignment or other means than the editor will you need to call Link.Add to force an update of the source file.</p> <p>Changes made to source files, including the addition of new <code>.apla</code>files, will always be reflected in the workspace, if the link has been set up to watch the file system.</p>"},{"location":"Usage/#setting-up-development-and-runtime-environments","title":"Setting up Development and Runtime Environments","text":"<p>We have seen how to use <code>]Link.Create</code>to load textual source into the workspace in order to work with it. As your project grows, you will probably want to split your code into modules, for example application code in one directory and shared utilities in another - and maybe also run some code to get things set up.</p> <p>Next, we will look at Setting up Development and Runtime Environments, so that you don't have to type the same sequence of things over and over again to get started with development - or running the application.</p>"},{"location":"Usage/Arrays/","title":"Array Formats","text":"<p>By default, Link uses APL Array Notation (APLAN) to store arrays in text files. While APLAN is a good format for describing numeric data, nested arrays and many high rank arrays, it is not ideal for storing text data. Link 4.0 introduced experimental support for storing multi-line character data in simple text files.</p> <p>The configuration setting <code>text</code> can be used to enable this feature: If <code>text</code> is set to <code>'aplan'</code> (the default) then all arrays will be store using APLAN. If <code>text</code> is set to <code>'plain'</code> then text arrays that adhere to a set of very specific criteria will instead be stored in plain text files. You can set this option when a link is created, or using <code>Link.Configure</code>.</p> <p>Text files which are not in APLAN format will have a penultimate \"sub-extension\" section in the file name which records the format of the original array in the workspace. The below table describes the array file extensions, what the content represents, and the specific criteria for storage in plain text file.</p> <p>For all plain text types, the array must be non-empty.</p> File Extension Array Characteristics Prohibited characters (<code>\u2395UCS</code>) .CR.apla Simple vector with each line terminated by <code>\u2395UCS 13</code> <code>10 11 12 133 8232 8233</code> .LF.apla Simple vector with each line terminated by <code>\u2395UCS 10</code> <code>11 12 13 133 8232 8233</code> .CRLF.apla Simple vector with each line terminated by <code>\u2395UCS 13 10</code> <code>11 12 133 8232 8233</code><sup>*</sup> .vec.apla Vector of simple character vectors (no scalar elements) <code>11 12 13 133 8232 8233</code> .mat.apla Simple character matrix <code>10 11 12 13 133 8232 8233</code> <p><sup>* In addition, every occurring <code>\u2395UCS 10</code> must be immediately preceded by a <code>\u2395UCS 13</code> and every occurring <code>\u2395UCS 13</code> must be immediately followed by <code>\u2395UCS 10</code>.</sup></p> <p>In all other cases, the extension will be just <code>.apla</code> and the file will contain APLAN that can represent any APL array.</p>"},{"location":"Usage/ConfigFiles/","title":"Configuration Files","text":""},{"location":"Usage/ConfigFiles/#introduction","title":"Introduction","text":"<p>Link Configuration files are in JSON5 format, which is the same format as Dyalog APL configuration files. There is a user configuration file containing options that apply to all links, and directory configuraton files which apply to individual directories.</p> <p>When performing an action that is related to a directory, Link will read both the user and directory configurations. If a setting is found in both places, the more specific directory setting will override the general user settting.</p>"},{"location":"Usage/ConfigFiles/#user-configuration-files","title":"User Configuration Files","text":"<p>You can have a user configuration file called <code>.linkconfig</code> , which records preferences that apply to all links, for example link creation options like -watch= or the <code>notify</code> setting. Under Microsoft Windows, this file is stored in the <code>Documents</code> folder, on other systems in the user's home directory.</p> <p>A simple example of a user configuration file would be:</p> <p><pre><code>{\n  LinkVersion: { ID: \"4.0.11\"},\n  Debug: {\n    notify: 1,\n  },\n  Settings: {\n    watch: \"ns\",\n  },\n}\n</code></pre> With the above user configuration file contents, Link will display notifications when processing changes to the source (notify:1), and default to only propagating changes from the namespace to source files (watch:ns). If a call to Link.Create includes an explicit setting of the <code>watch</code> option, that will override the default.</p> <p>Note that a configuration contains a <code>LinkVersion</code> section, which identifies the version of Link that wrote the file.</p>"},{"location":"Usage/ConfigFiles/#directory-configuration-files","title":"Directory Configuration Files","text":"<p>Each linked directory may contain a <code>.linkconfig</code> file containing defaults that will apply when a link is created to that directory, or if the directory is imported. When Link.Create or Link.Export create a directory and create files in it, any non-default switch settings provided to tha API function will be recorded in a configuration file within the directory. This means that you no longer need to remember the options used to re-create the original link when continuing work, or importing the link into a runtime environment.</p> <p>If you already have a Link folder which was created by an earlier version of Link, you can add a <code>.linkconfig</code> file using Link.Configure. For example:</p> <p><pre><code>      ]Link.Create linkdemo /tmp/linkdemo\n      ]Link.Configure linkdemo flatten:1\nWas  flatten: \n</code></pre> The result documents that there was no previous setting for the option. A file called <code>/tmp/linkdemo/.linkconfig</code> is created, with the following contents:</p> <pre><code>{\n  LinkVersion: { ID: \"4.0.11\"},\n  Settings: {\n    flatten: 1,\n  },\n}\n</code></pre>"},{"location":"Usage/ConfigFiles/#stop-and-trace-flags","title":"Stop and Trace flags","text":"<p>Directory configuration files also record stop and trace settings for functions and operators in the linked directory, which you can either manipulate in the editor, or using the API functions Link.Stop and Link.Trace:</p> <p><pre><code>      ]link.stop linkdemo.stats.Mean 2\nWas linkdemo.stats.Mean 1\n</code></pre> These settings are recorded in a <code>SourceFlags</code> section of our configuration file, which now looks like this:</p> <pre><code>{\n  LinkVersion: { ID: \"4.0.11\"},\n  Settings: {\n    flatten: 1,\n  },\n  SourceFlags: [\n    {\n      Name: \"stats.Mean\",\n      Stop: [\n        2,        \n      ],\n    },    \n  ],\n}\n</code></pre> <p>Note that there is no support for storing <code>\u2395MONITOR</code> settings, as these are usually set under program control and used for reporting.</p>"},{"location":"Usage/ConfigFiles/#linkconfigure","title":"Link.Configure","text":"<p>The Link.Configure API function and the corresponding user command, can be used to query and set the contents of both user and directory configuration files. For example, following on from the above example, we can query the current settings:</p> <pre><code>      ]link.configure linkdemo\nContents of \"c:/tmp/linkdemo/.linkconfig\":\n   Settings  :  flatten:1 \n\n      ]link.configure *\nContents of \"C:\\Users\\mkrom\\Documents\\.linkconfig\":\n   Debug     :  notify:1 \n   Settings  :  watch:ns \n</code></pre> <p>You can change the settings by adding name:value pairs, and completely remove a setting by putting nothing after the colon:</p> <pre><code>      ]link.configure linkdemo flatten:0\nWas  flatten:1 \n      ]link.configure linkdemo\nContents of \"c:/tmp/linkdemo/.linkconfig\":\n   Settings  :  flatten:0\n      ]link.configure linkdemo flatten:\nWas  flatten:1 \n      ]link.configure linkdemo\nNo configuration options set in \"c:/tmp/linkdemo/.linkconfig\"\n</code></pre>"},{"location":"Usage/ConfigFiles/#the-configuration-file-format","title":"The Configuration File Format","text":"<p>User and directory configuration files have the same format, with up to four top level names:</p> <ul> <li>LinkVersion identifies the version of Link that wrote the file.</li> <li>Settings This section can contain settings for most Link API function options. For a complete list, see the      documentation for Link.Create.</li> <li>Debug This section can contain two settings, debug and notify that assist with debugging Link, they are primarily aimed at Link Developers or expert APL users who believe Link might be misbehaving.<ul> <li>debug:1 Disables error trapping within Link API functions</li> <li>debug:2 Stops at the beginning of each Link API call, to facilitate tracing</li> <li>notify:1 Causes Link to write confirmation to the APL session each time it defines a function</li> </ul> </li> <li>SourceFlags Unlike Debug and Settings, SourceFlags is an array with one element per function or operator which has saved Stop and Trace settings. Each array element will contain a Name property, which is the name of the function or operator, and it may contain Stop and Trace, which are integer vectors containing line numbers.</li> </ul> <p>An example of a configuration file with information in all sections is:</p> <pre><code>{\n  LinkVersion: { ID: \"4.0.11\"},\n  Debug: {\n    notify:1,\n  },\n  Settings: {\n    watch: \"ns\"1,\n  },\n  SourceFlags: [\n    {\n      Name: \"stats.Mean\",\n      Stop: [\n        2,        \n      ],\n    },    \n  ],\n}\n</code></pre>"},{"location":"Usage/ConfigFiles/#the-ignoreconfig-switch","title":"The <code>ignoreconfig</code> switch","text":"<p>If you manually edit a <code>.linkconfig</code> file and damage it so that it either becomes invalid JSON5 so that Link is unable to read it, or if Link is able to read it but complains that it has invalid contents, or if you simply want to ignore the configuration for other reasons, several API functions including Create, Import and Export have an <code>ignoreconfig</code> option:</p> <pre><code>      ]link.create linkdemo c:\\tmp\\linkdemo\nUnknown Setting(s) in \"c:\\tmp\\linkdemo/.linkconfig\":  fasten \n      ]link.create linkdemo c:\\tmp\\linkdemo -ignoreconfig\nLinked: #.linkdemo \u2190\u2192 c:\\tmp\\linkdemo\n</code></pre>"},{"location":"Usage/Installation/","title":"Installation","text":"<p>Link 4.1 is </p> <ul> <li>included with Dyalog version 20.0</li> <li>supported for use with version 19.0</li> </ul> <p>Some Link functionality needs .NET \u2013 see below.</p> <p>Use these instructions install a different Link version from that distributed with your version of Dyalog</p> <pre><code>??? detail \"How to display your installed Link version\"\n\n    ```apl\n          \u2395SE.Link.Version\n    4.1.3       \n    ```\n</code></pre>"},{"location":"Usage/Installation/#net","title":".NET","text":"<p>.NET allows Dyalog to update workspace contents automatically when you use external editors or source code management systems to edit the files. Without .NET, watch can only be set to <code>ns</code> and Link can only update files with changes made by the Dyalog editor or using Link.Add. That said, you can always resync manually.</p> <p>Link has been tested with .NET Framework version 4 and .NET version 8, and is expected to work with any later version of .NET.</p> Microsoft WindowsLinux, macOSAIX <p>The .NET Framework is already installed; there is nothing for you to do.</p> <p>Download .NET and follow the installation instructions.</p> <p>dotnet.microsoft.com/download </p> <p>.NET is not available for AIX. Therefore watch can only be set to ns and Link can only update files with changes made by the Dyalog editor. The workspace contents will not be updated as a result of changes made by external editors. That said, you can always resync manually.</p>"},{"location":"Usage/Installation/#step-2-download-a-link-zip","title":"Step 2: Download a Link ZIP","text":"<p> Download the link-v4.1.nn.zip (<code>nn</code> is a Link patch number).</p> <p>Extract subfolder <code>StartupSession/Link</code>.</p>"},{"location":"Usage/Installation/#step-3-install-your-link-folder","title":"Step 3: Install your Link folder","text":""},{"location":"Usage/Installation/#in-the-default-location","title":"In the default location","text":"<p>The Link folder belongs in the <code>StartupSession</code> folder. By default, this is</p> Microsoft WindowsLinux, macOS, AIX <p>where Dyalog is installed, e.g.</p> <pre><code>C:\\Program Files\\Dyalog\\Dyalog APL-64 19.0 Unicode\\StartupSession\n</code></pre> <p>within your home folder, e.g.</p> <pre><code>~/dyalog.200U64.files/StartupSession  \u235d Dyalog 20.0\n~/dyalog.190U64.files/StartupSession  \u235d Dyalog 19.0\n</code></pre> <p>If you have write access to the default location</p> <ul> <li>move the <code>Link</code> folder outside it (as a fallback)</li> <li>copy the extracted <code>Link</code> folder into it</li> </ul>"},{"location":"Usage/Installation/#in-a-custom-location","title":"In a custom location","text":"<p>If you do not have write access to the default location</p> <ol> <li>Make a new folder in your home directory</li> <li> <p>Copy the extracted <code>StartupSession</code> folder to it</p> <p>E.g.</p> Microsoft WindowsLinux, macOS, AIX <pre><code>C:\\Users\\mkrom\\mydyalogfiles\\StartupSession\\Link\n</code></pre> <pre><code>~/mydyalogfiles/StartupSession/Link\n</code></pre> </li> <li> <p>Declare the custom location of your Link folder</p> Microsoft WindowsLinux, macOS, AIX <p>In the Windows Registry, set the environment variable as below.</p> <p>Select a configuration file. </p> <pre><code>~/.dyalog/dyalog.config       \u235d all versions of Dyalog\n~/.dyalog/dyalog.200U64.dcfg  \u235d specific version, such as 20.0\n</code></pre> <p>In your configuration file, set the environment variable as below.</p> <p>Declare as <code>DYALOGLINK</code> the filepath that contains the <code>StartupSession</code> folder. Some examples:</p> <pre><code>DYALOGLINK  C:\\Users\\mkrom\\mydyalogfiles\n\nDYALOGLINK: \"[HOME]/dyalog.190U64.files\",\nDYALOGLINK: \"[HOME]/mydyalogfiles\",\nDYALOGLINK: \"/Users/mkrom/\",\n</code></pre> </li> </ol>"},{"location":"Usage/Installation/#step-4-refresh-the-user-commands","title":"Step 4: Refresh the user commands","text":"<pre><code>      ]ureset\n153 commands reloaded\n</code></pre>"},{"location":"Usage/Installation/#step-5-display-the-link-version","title":"Step 5: Display the Link version","text":"<p>Test your installation by querying the Link version.</p> <p>Quit and restart APL. Confirm you see the Link version you intended to install.</p> <pre><code>      \u2395SE.Link.Version\n4.1.3\n</code></pre>"},{"location":"Usage/Setup/","title":"Setting Up Your Application","text":"<p>With a small project, you can get by using <code>Link.Create</code> or <code>Link.Import</code> to bring your source into the workspace in order to work with it. However, even in a small project, this quickly gets tedious, and as the project grows, you may want to load code from more that one directory, and perhaps run some code in order to set things up or even start the application. </p> <p>Eventually, you may want to look at a project management system like Cider, but that's a different story. Until you reach that point, you can use the Link API to automate the loading and running of your application.</p>"},{"location":"Usage/Setup/#example","title":"Example","text":"<p>To illustrate, we will create a small application that uses the stats library that we created in the section on basic usage. We will put the application into a namespace called <code>linkdemo</code>:</p> <pre><code>      )clear\nclear ws\n      )ns linkdemo\n      ]link.create linkdemo /users/sally/linkdemo\nLinked: #.linkdemo \u2190\u2192 /users/sally/linkdemo\n\n      )ed linkdemo.Main\n</code></pre> <p>Our application is going to prompt the user for an input array and output the mean and standard deviation of the data, until the user inputs an empty array. Obviously, the code should be enhanced to validate the input and perhaps trap errors, but that is left as an exercise for the reader.</p> <pre><code>     \u2207 Main;data                                           \n[1]   \u235d Compute Mean and StdDev until user inputs an empty array\n[2]                                                             \n[3]    :Repeat                                                  \n[4]        \u2395\u2190'Enter some numbers:'                              \n[5]        :If 0\u2260\u2374data\u2190\u2395                                        \n[6]            \u2395\u2190'Mean:   ',1\u2355#.stats.Mean data                      \n[7]            \u2395\u2190'StdDev: ',1\u2355#.stats.StdDev data                    \n[8]        :EndIf                                               \n[9]    :Until 0=\u2262data                                           \n     \u2207                                                                                   \n</code></pre> <p>We will need the <code>stats</code> code in the workspace as well, of course. Since we only intend to use it and don't want to risk making changes to its source code while testing our own application, we will use <code>]link.import</code> rather than <code>]link.create</code> to bring that code into the workspace. Note that after the import, <code>]link.status</code> still only reports a single link:</p> <pre><code>      ]link.import stats /users/sally/stats\nImported: #.stats \u2190 /users/tmp/stats\n\n      ]link.status\n Namespace    Directory             Files\n #.linkdemo   /users/sally/linkdemo     1  \n\n      linkdemo.Main\n      Enter some numbers:\n\u2395:\n      50+?100\u2374100\nMean:    102.4\nStdDev:  30.1\nEnter some numbers:\n\u2395:\n      \u236c\n</code></pre>"},{"location":"Usage/Setup/#automating-startup","title":"Automating Startup","text":"<p>Starting with Dyalog APL version 18.0, it is simple to launch the interpreter from a text file: either a source file defining a function, namespace or class using the LOAD parameter or from a configuration file using the  CONFIGFILE parameter. From version 18.2, <code>LOAD</code> can also indentify a directory, in which case APL will create a link to the directory on startup, and attempt to call the function <code>#.Run</code>, with the enclosed name of the directory as the right argument. You can skip or replace the call to <code>Run</code> by adding <code>LX=</code> to your command line.</p> <p>Using <code>LOAD</code> to link to a directory on startup is simple way to handle very simple applications or ad-hoc development. However, configuration files allow you to both set a startup expression and include other configuration options for the interpreter and are probably a better solution for applications consisting of more than one source directory. For example, we could start our example application by creating a file <code>dev.dcfg</code> in the <code>linkdemo</code> folder with the following contents:</p> <pre><code>{\n  Settings: {\n      MAXWS: \"100M\",\n      LX: \"linkdemo.Start 0 \u22a3 \u2395\u2190\u2395SE.Link.Create 'linkdemo' \u2395SE.Link.LaunchDir\"\n  }\n}\n</code></pre> <p>This specifies an APL session with a MAXWS of 100 megabytes, which will start by creating the <code>linkdemo</code>  namespace and calling <code>linkdemo.Start</code>. The namespace will be created using the directory named by the result of the function <code>\u2395SE.Link.LaunchDir</code>; this will be the directory that the CONFIGFILE parameter refers to (or, if there is no CONFIGFILE, the directory referred to by the LOAD parameter).</p> <p>The function <code>linkdemo.Start</code> will bring in the <code>stats</code> library using <code>Link.Import</code>: since we are not developers of this library, we don't want to create a bi-directional link that might allow us to accidentally modify it during our testing. It also creates the name <code>ST</code> to point to the stats library, which means that our <code>Main</code> function can use more pleasant names, like <code>ST.Mean</code> in place of <code>#.stats.Mean</code> - which also makes it easier to relocate that module in the workspace:</p> <pre><code>     \u2207 Start run                                                                       \n[1]   \u235d Establish development environment for the linkdemo application                 \n[2]                                                                                    \n[3]    \u2395IO\u2190\u2395ML\u21901                                                                       \n[4]    \u2395SE.Link.Import '#.stats' '/users/sally/stats' \u235d Load the stats library\n[5]    ST\u2190#.stats\n[6]    :If run                                                                         \n[7]        Main                                                                        \n[8]        \u2395OFF                                                                        \n[9]    :EndIf                                                                          \n     \u2207                                                                                 \n</code></pre> <p>We can now launch our development environment using <code>dyalog CONFIGFILE=linkdemo/devt.cfg</code>, or on some platforms right-clicking on this file and selecting Run.</p>"},{"location":"Usage/Setup/#development-vs-runtime","title":"Development vs Runtime","text":"<p>The <code>Start</code> function takes a right argument <code>run</code> which decides whether it should just exit after initialising the environment, or it should launch the application by calling <code>Main</code> and terminate the session when the user decides that the job is done.</p> <p>This allows us to create a second configuration file, <code>linkdemo/run.dcfg</code>, which differs from <code>dev.dcfg</code> in that we reserve a bigger workspace (since we'll be doing real work rather than just testing), and brings the source code in using <code>Link.Import</code> rather than <code>Link.Create</code>, which means that we won't waste resources setting up a file system watcher, and that accidental changes made by anyone running the application will not update the source files.</p> <pre><code>{\n  Settings: {\n      MAXWS: \"1G\",\n      LX: \"linkdemo.Start 1 \u22a3 \u2395\u2190\u2395SE.Link.Import 'linkdemo' \u2395SE.Link.LaunchDir\"\n  }\n}\n</code></pre>"},{"location":"Usage/Setup/#distribution-workspace","title":"Distribution Workspace","text":"<p>As we have seen, Link allows you to run your application based entirely on textual source files. However, if you have a lot of source files it may be more convenient for the users of your application to receive a single workspace file with all of the source loaded. </p> <p>To prepare a workspace for shipment, we will need to:</p> <ul> <li>Set <code>\u2395LX</code> in the so that it calls the <code>Start</code> function</li> <li>Use Link.Break to remove links to the source files. If you omit this step, you can create an extremely confusing situation.</li> <li><code>)SAVE</code> the workspace</li> </ul>"},{"location":"Usage/Setup/#scripted-applications","title":"Scripted Applications","text":"<p>Recent versions of Dyalog APL support running APL from a script either by redirecting input to a normal APL interpreter or (recommended from version 18.2) using the new script engine. When the interpreter is running from a script, it intentionally provides you with a completely clean environment without any development tools loaded. This means that the session namespace is not populated, and Link is not loaded. If you add the following line to the top of your script, it will (amongst other things) bring Link into the session so that the API becomes available: <pre><code>#! dyalogscript DYALOG_INITSESSION=1\n</code></pre></p>"},{"location":"Usage/WStoLink/","title":"Converting an Existing Workspace to use Link","text":"<p>In order to start using Link to maintain code that resides in a workspace, you first need to export the code in the workspace to one or more folders.</p> <p>The simplest way to do this is to use Link.Export. In principle, it should be possible to write the entire contents of any workspace to an empty folder called <code>/folder/name</code> using the following:</p> <pre><code>      'options' \u2395NS \u236c\n      options.(arrays sysVars)\u21901\n      options \u2395SE.Link.Export # '/folder/name'\n</code></pre> <p>or equivalently, using the user command:</p> <pre><code>      ]link.export # /folder/name -arrays -sysvars\n</code></pre> <p>You can also use Link.Create with the same arguments, if you want an active link to exist after the export has been done.</p>"},{"location":"Usage/WStoLink/#options","title":"Options","text":""},{"location":"Usage/WStoLink/#-arrays","title":"-arrays","text":"<p>By default, Link assumes that the \"source code\" only consists of functions, operators, namespaces and classes. Variables are assumed to contain data which is transient and thus not part of the source. The <code>-arrays</code> causes all arrays in the workspace to be written to source files as well. You can also write selected variables to file, see the documentation for Link.Create for more options.</p>"},{"location":"Usage/WStoLink/#-sysvars","title":"-sysVars","text":"<p>By default, Link will assume that you do not wish to record the settings for system variables, because your source will be loaded into an environment that already has the desired settings. If you want to be 100% sure to re-create your workspace exactly as it is, you can use <code>-sysVars</code> to record the values of system variables from each namespace in source files.</p> <p>Beware that this will add a lot of mostly redundant files to your repository. It is probably a better idea to analyse your workspace carefully and only write system variables to file if you really need them, using Link.Add.</p>"},{"location":"Usage/WStoLink/#workspaces-containing-namespaces","title":"Workspaces containing Namespaces","text":"<p>If your workspace is logically divided up into namespaces and you are happy for them all to end up in the same directory, you can use a single call to Link.Export or Link.Create like the one at the beginning of this section to write everything out at once. If you don't want the workspace to end up as a single directory tree, you can either restructure things afterwards using file explorers or command line tools, or you can make several separate calls to Export or Create to write the contents of individual namespaces to different locations.</p> <p>Of course, if you create more than one source directory, you will need make more than one call to Link.Create or Link.Import in order to re-create the workspace in order to run your code.</p>"},{"location":"Usage/WStoLink/#flat-workspaces-and-the-flatten-switch","title":"Flat Workspaces and the <code>-flatten</code> Switch","text":"<p>If your workspace is not divided into namespaces, but all your code and data are in the root (or #) namespace, it probably still consists of more than logically distinct sets of code (\"modules\"), that you might wish to manage separately. If you Export such a workspace, all the source files will obviously end up in the same folder.</p> <p>If you subsequently separate the source files into separate folders in order to make the source more manageable, you can still load it all into a single \"flat\" namespace using the <code>-flatten</code>switch. This allows the code to run unchanged, although you have created a structure for the source.</p> <p>The mappings to source files will be recorded, so that synchronisation will work if you edit the code in the APL system or using an external editor. If you create a new name inside the workspace, Link will obviously not know which folder to write it to, and will prompt you to specify a target folder.</p>"},{"location":"Usage/WStoLink/#recreating-the-workspace","title":"Recreating the Workspace","text":"<p>In order to recreate the workspace from source, you will need to make one or more calls to <code>Link.Create</code> or <code>Link.Import</code>, depending on the structure that you have created. For some ideas on how to set this up, see Setting up your Environment.</p>"}]}